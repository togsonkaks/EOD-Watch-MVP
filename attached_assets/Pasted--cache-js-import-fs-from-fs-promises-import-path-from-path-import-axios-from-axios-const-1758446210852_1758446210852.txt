// cache.js
import fs from 'fs/promises';
import path from 'path';
import axios from 'axios';

const CACHE_DIR = path.join(process.cwd(), 'cache');
await fs.mkdir(CACHE_DIR, { recursive: true });

const TIINGO_TOKEN = process.env.TIINGO_TOKEN; // set this!

function cachePath(symbol, timeframe = '1d') {
  return path.join(CACHE_DIR, `${symbol.toUpperCase()}_${timeframe}.json`);
}

async function readCache(symbol, timeframe) {
  try {
    const p = cachePath(symbol, timeframe);
    const raw = await fs.readFile(p, 'utf8');
    return JSON.parse(raw);
  } catch {
    return { meta: null, bars: [] };
  }
}

async function writeCache(symbol, timeframe, data) {
  const p = cachePath(symbol, timeframe);
  await fs.writeFile(p, JSON.stringify(data), 'utf8');
}

function ymd(date) {
  return date.toISOString().slice(0,10); // YYYY-MM-DD
}

async function fetchTiingoDaily(symbol, startDateYMD = null) {
  // Docs: Tiingo EOD supports ?startDate=YYYY-MM-DD to fetch from a date
  const base = `https://api.tiingo.com/tiingo/daily/${encodeURIComponent(symbol)}/prices`;
  const url = startDateYMD
    ? `${base}?startDate=${startDateYMD}&token=${TIINGO_TOKEN}`
    : `${base}?token=${TIINGO_TOKEN}`;
  const { data } = await axios.get(url, { timeout: 15000 });
  // Normalize to {time, open, high, low, close, volume}
  return (data || []).map(row => ({
    time: row.date,                 // ISO string
    open: row.open,
    high: row.high,
    low: row.low,
    close: row.close,
    volume: row.volume ?? null
  }));
}

export async function getDailyBarsCached(symbol, days = 600, timeframe = '1d') {
  if (!TIINGO_TOKEN) throw new Error('Missing TIINGO_TOKEN');

  const today = ymd(new Date());
  let { meta, bars } = await readCache(symbol, timeframe);

  // First-time fetch
  if (!meta) {
    const fetched = await fetchTiingoDaily(symbol);   // full history (Tiingo limits apply)
    // Keep only what you care about (e.g., last 5y ≈ 1260 trading days)
    const MAX_BARS = 1500;
    bars = fetched.slice(-MAX_BARS);
    meta = { last_fetch_at: new Date().toISOString(), last_bar_date: bars.at(-1)?.time ?? null };
    await writeCache(symbol, timeframe, { meta, bars });
  }

  // If today’s bar isn’t present, fetch just the delta since last_bar_date+1
  const haveLatest = meta.last_bar_date && meta.last_bar_date >= today;
  if (!haveLatest) {
    const start = meta.last_bar_date ? ymd(new Date(Date.parse(meta.last_bar_date) + 24*3600*1000)) : null;
    const delta = await fetchTiingoDaily(symbol, start);
    if (delta.length) {
      // Append, ensuring no duplicates
      const existing = new Set(bars.map(b => b.time));
      for (const d of delta) if (!existing.has(d.time)) bars.push(d);
      // Trim to MAX_BARS
      const MAX_BARS = 1500;
      if (bars.length > MAX_BARS) bars = bars.slice(-MAX_BARS);
      meta.last_bar_date = bars.at(-1)?.time ?? meta.last_bar_date;
      meta.last_fetch_at = new Date().toISOString();
      await writeCache(symbol, timeframe, { meta, bars });
    }
  }

  // Return the trailing window requested
  const n = Math.max(1, Number(days) | 0);
  return { symbol: symbol.toUpperCase(), data: bars.slice(-n) };
}
