<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>EOD Watch â€” Minimal</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Lightweight Charts -->
  <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    html, body { margin:0; padding:0; background:#0e1a24; color:#cbd5e1; height:100%; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    #app { display:flex; height:100%; }
    #sidebar { width:250px; background:#0b1220; border-right:1px solid #1f2937; display:flex; flex-direction:column; }
    #main { flex:1; display:flex; flex-direction:column; }
    header { padding:8px 12px; border-bottom:1px solid #1f2937; display:flex; gap:8px; align-items:center; justify-content:space-between; }
    #current-symbol { font-size:18px; font-weight:600; color:#60a5fa; }
    #timeframes { display:flex; gap:4px; }
    .timeframe-btn { background:#374151; color:#cbd5e1; border:0; border-radius:4px; padding:4px 8px; font-size:12px; cursor:pointer; }
    .timeframe-btn.active { background:#1d4ed8; }
    #chart { flex:1 1 auto; min-height: 520px; position:relative; }
    .drawing-mode #chart { cursor: crosshair; }
    .loading-overlay { position:absolute; top:0; left:0; right:0; bottom:0; background:rgba(14,26,36,0.8); display:none; align-items:center; justify-content:center; color:#60a5fa; font-size:14px; }
    .loading-overlay.show { display:flex; }
    #log { padding:6px 12px; font-size:12px; border-top:1px solid #1f2937; color:#9ca3af; }
    
    /* Watchlist styles */
    #watchlist-header { padding:12px; border-bottom:1px solid #1f2937; }
    #add-symbol { display:flex; gap:4px; margin-bottom:8px; }
    #new-symbol { flex:1; }
    #watchlist { flex:1; overflow-y:auto; }
    .symbol-item { padding:8px 12px; cursor:pointer; border-bottom:1px solid #1e293b; display:flex; justify-content:space-between; align-items:center; }
    .symbol-item:hover { background:#1e293b; }
    .symbol-item.active { background:#1d4ed8; }
    .symbol-name { font-weight:500; }
    .remove-btn { background:#dc2626; font-size:12px; padding:2px 6px; border-radius:3px; }
    
    /* Indicators */
    #indicators { padding:8px 12px; border-bottom:1px solid #1f2937; }
    .indicator-toggle { display:flex; align-items:center; gap:6px; margin-bottom:4px; font-size:12px; }
    .toggle-switch { width:32px; height:16px; background:#374151; border-radius:8px; position:relative; cursor:pointer; }
    .toggle-switch.active { background:#1d4ed8; }
    .toggle-knob { width:12px; height:12px; background:#fff; border-radius:50%; position:absolute; top:2px; left:2px; transition:left 0.2s; }
    .toggle-switch.active .toggle-knob { left:18px; }
    
    /* Drawing Tools */
    #drawing-tools { padding:8px 12px; border-bottom:1px solid #1f2937; }
    .tool-btn { background:#374151; color:#cbd5e1; border:0; border-radius:4px; padding:6px 8px; font-size:12px; cursor:pointer; margin-right:4px; margin-bottom:4px; }
    .tool-btn.active { background:#1d4ed8; }
    
    /* Levels */
    #levels { padding:8px 12px; flex:1; overflow-y:auto; }
    .level-item { display:flex; align-items:center; justify-content:space-between; padding:4px 0; border-bottom:1px solid #1e293b; }
    .level-price { font-family:monospace; font-size:11px; color:#60a5fa; }
    .level-controls { display:flex; gap:4px; }
    .level-controls button { background:none; border:0; color:#9ca3af; cursor:pointer; padding:2px; }
    .level-controls button:hover { color:#cbd5e1; }
    
    /* Status indicators */
    .status-dot { width:8px; height:8px; border-radius:50%; margin-right:6px; }
    .status-connected { background:#10b981; }
    .status-loading { background:#f59e0b; animation:pulse 1.5s infinite; }
    .status-error { background:#dc2626; }
    @keyframes pulse { 0%, 100% { opacity:1; } 50% { opacity:0.5; } }
    
    /* Improved hover states */
    .symbol-item:hover, .tool-btn:hover, .timeframe-btn:hover { transform:translateY(-1px); transition:transform 0.1s; }
    
    /* Better visual feedback */
    .tool-btn.active { box-shadow:0 0 8px rgba(29,78,216,0.4); }
    
    /* Line Controls */
    #line-controls { padding:8px 12px; border-bottom:1px solid #1f2937; display:none; }
    .color-picker { display:flex; gap:4px; margin:4px 0; }
    .color-option { width:20px; height:20px; border-radius:50%; cursor:pointer; border:2px solid transparent; }
    .color-option.active { border-color:#60a5fa; }
    .color-option:hover { transform:scale(1.1); }
    
    /* Responsive improvements */
    @media (max-width: 768px) {
      #sidebar { width:200px; }
      .timeframe-btn { padding:3px 6px; font-size:11px; }
    }
    
    button { background:#1d4ed8; color:#fff; border:0; border-radius:6px; padding:6px 10px; cursor:pointer; }
    button:disabled { opacity:.5; cursor:not-allowed; }
    input { background:#0b1220; color:#e5e7eb; border:1px solid #374151; border-radius:6px; padding:6px 8px; }
  </style>
</head>
<body>
<div id="app">
  <div id="sidebar">
    <div id="watchlist-header">
      <h3 style="margin:0 0 8px 0; font-size:14px; color:#9ca3af;">WATCHLIST</h3>
      <div id="add-symbol">
        <input id="new-symbol" placeholder="Add symbol..." />
        <button id="add-btn">+</button>
      </div>
    </div>
    <div id="watchlist"></div>
    <div id="indicators">
      <h4 style="margin:0 0 8px 0; font-size:12px; color:#9ca3af;">INDICATORS</h4>
      <div class="indicator-toggle">
        <div class="toggle-switch active" id="ema-toggle">
          <div class="toggle-knob"></div>
        </div>
        <span>EMA(200)</span>
      </div>
      <div class="indicator-toggle">
        <div class="toggle-switch" id="bb-toggle">
          <div class="toggle-knob"></div>
        </div>
        <span>BB(20,2)</span>
      </div>
    </div>
    <div id="drawing-tools">
      <h4 style="margin:0 0 8px 0; font-size:12px; color:#9ca3af;">DRAWING</h4>
      <button class="tool-btn" id="level-tool">Level</button>
      <button class="tool-btn" id="trendline-tool">Trendline</button>
      <button class="tool-btn" id="clear-all">Clear</button>
    </div>
    <div id="line-controls">
      <h4 style="margin:0 0 8px 0; font-size:12px; color:#9ca3af;">LINE OPTIONS</h4>
      <div class="color-picker">
        <div class="color-option" style="background:#60a5fa" data-color="#60a5fa" title="Blue"></div>
        <div class="color-option" style="background:#f59e0b" data-color="#f59e0b" title="Orange"></div>
        <div class="color-option" style="background:#10b981" data-color="#10b981" title="Green"></div>
        <div class="color-option" style="background:#ef4444" data-color="#ef4444" title="Red"></div>
        <div class="color-option" style="background:#8b5cf6" data-color="#8b5cf6" title="Purple"></div>
        <div class="color-option" style="background:#f97316" data-color="#f97316" title="Yellow"></div>
      </div>
      <button class="tool-btn" id="delete-line" style="background:#dc2626; width:100%; margin-top:4px;">Delete Selected Line</button>
    </div>
    <div id="levels">
      <h4 style="margin:0 0 8px 0; font-size:12px; color:#9ca3af;">LEVELS</h4>
      <div id="levels-list"></div>
    </div>
  </div>
  <div id="main">
    <header>
      <div style="display:flex; align-items:center;">
        <div class="status-dot status-connected" id="status-dot"></div>
        <div id="current-symbol">AAPL</div>
      </div>
      <div id="timeframes">
        <button class="timeframe-btn active" data-tf="1D">1D</button>
        <button class="timeframe-btn" data-tf="1W" title="Weekly aggregation (Phase 3)">1W</button>
        <button class="timeframe-btn" data-tf="1M" title="Monthly aggregation (Phase 3)">1M</button>
      </div>
    </header>
    <div id="chart">
      <div class="loading-overlay" id="loading-overlay">
        <div>Loading chart data...</div>
      </div>
    </div>
    <div id="log">â€”</div>
  </div>
</div>

<script>
(function () {
  const API = ''; // same origin
  const $ = s => document.querySelector(s);
  const $$ = s => document.querySelectorAll(s);
  const log = m => { $('#log').textContent = m; console.log('[EOD]', m); };

  // ---- Application State
  let watchlist = JSON.parse(localStorage.getItem('eod-watchlist') || '["AAPL", "META", "TSLA", "GOOGL", "MSFT"]');
  let currentSymbol = localStorage.getItem('eod-current-symbol') || 'AAPL';
  let indicators = JSON.parse(localStorage.getItem('eod-indicators') || '{"ema200": true, "bb20": false}');
  let levels = JSON.parse(localStorage.getItem('eod-levels') || '{}'); // symbol -> levels mapping
  let trendlines = JSON.parse(localStorage.getItem('eod-trendlines') || '{}'); // symbol -> trendlines mapping
  let drawingMode = false;
  let drawingTool = 'level'; // 'level' or 'trendline'
  let trendlineStart = null; // for 2-point trendline drawing
  let previewTrendline = null; // preview line while drawing
  let currentLevels = []; // active level lines on chart
  let currentTrendlines = []; // active trendlines on chart
  let selectedLine = null; // currently selected line for editing
  let lineHandles = []; // visual handles for selected line
  let isLineSelected = false; // flag to track selection state

  // ---- Chart init
  const chart = LightweightCharts.createChart(document.getElementById('chart'), {
    autoSize: true,
    layout: { background: { color: '#0e1a24' }, textColor: '#cbd5e1' },
    grid: { vertLines: { color: '#1f2937' }, horzLines: { color: '#1f2937' } },
    rightPriceScale: { borderColor: '#334155' },
    timeScale: { borderColor: '#334155' }
  });
  const candleSeries = chart.addCandlestickSeries();
  // indicators
  const emaSeries = chart.addLineSeries({ color: '#60a5fa', lineWidth: 2 });
  const bbUpperSeries = chart.addLineSeries({ color: '#f59e0b', lineWidth: 1 });
  const bbMiddleSeries = chart.addLineSeries({ color: '#f59e0b', lineWidth: 1, lineStyle: 2 });
  const bbLowerSeries = chart.addLineSeries({ color: '#f59e0b', lineWidth: 1 });

  // ---- Indicator calculations
  function ema(values, period) {
    if (values.length === 0) return [];
    const k = 2 / (period + 1);
    let emaVal = values[0].close;
    const out = [{ time: values[0].time, value: emaVal }];
    for (let i = 1; i < values.length; i++) {
      emaVal = values[i].close * k + emaVal * (1 - k);
      out.push({ time: values[i].time, value: emaVal });
    }
    return out;
  }

  function bollingerBands(values, period, stdDev) {
    if (!values || values.length < period) return { upper: [], middle: [], lower: [] };
    
    const upper = [], middle = [], lower = [];
    
    for (let i = period - 1; i < values.length; i++) {
      // Calculate SMA for middle band
      const slice = values.slice(i - period + 1, i + 1);
      
      // Ensure all values are valid numbers
      const validSlice = slice.filter(bar => bar && typeof bar.close === 'number' && !isNaN(bar.close));
      if (validSlice.length !== slice.length) continue; // Skip if any invalid data
      
      const sma = validSlice.reduce((sum, bar) => sum + bar.close, 0) / validSlice.length;
      
      // Calculate standard deviation
      const variance = validSlice.reduce((sum, bar) => sum + Math.pow(bar.close - sma, 2), 0) / validSlice.length;
      const std = Math.sqrt(variance);
      
      const time = values[i].time;
      if (time && !isNaN(sma) && !isNaN(std)) {
        middle.push({ time, value: sma });
        upper.push({ time, value: sma + (stdDev * std) });
        lower.push({ time, value: sma - (stdDev * std) });
      }
    }
    
    return { upper, middle, lower };
  }

  async function fetchBars(symbol, days = 600) {
    const url = `${API}/eod?symbol=${encodeURIComponent(symbol)}&days=${days}`;
    const r = await fetch(url);
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    const json = await r.json();
    // Tiingo adapter -> Lightweight Charts
    return (json.data || []).map(b => ({
      time: b.time, open: b.open, high: b.high, low: b.low, close: b.close
    }));
  }

  async function loadSymbol(sym) {
    try {
      // Show loading state
      $('#loading-overlay').classList.add('show');
      $('#status-dot').className = 'status-dot status-loading';
      log(`Loading ${sym}â€¦`);
      
      const bars = await fetchBars(sym, 600);
      if (!bars.length) { 
        log('No data returned.'); 
        $('#status-dot').className = 'status-dot status-error';
        return; 
      }
      
      // Update chart
      candleSeries.setData(bars);
      
      // Update indicators based on toggles
      if (indicators.ema200) {
        const ema200 = ema(bars, 200);
        emaSeries.setData(ema200);
      } else {
        emaSeries.setData([]);
      }
      
      if (indicators.bb20) {
        const bb = bollingerBands(bars, 20, 2);
        bbUpperSeries.setData(bb.upper);
        bbMiddleSeries.setData(bb.middle);
        bbLowerSeries.setData(bb.lower);
      } else {
        bbUpperSeries.setData([]);
        bbMiddleSeries.setData([]);
        bbLowerSeries.setData([]);
      }
      
      chart.timeScale().fitContent();
      currentSymbol = sym;
      $('#current-symbol').textContent = sym;
      localStorage.setItem('eod-current-symbol', sym);
      updateWatchlistDisplay();
      updateLevelsDisplay();
      drawLevelsOnChart();
      updateTrendlinesDisplay();
      drawTrendlinesOnChart();
      
      // Update status to connected
      $('#status-dot').className = 'status-dot status-connected';
      log(`Loaded ${sym}: ${bars.length} bars`);
    } catch (e) {
      log('Load failed: ' + e.message);
      $('#status-dot').className = 'status-dot status-error';
    } finally {
      // Hide loading state
      $('#loading-overlay').classList.remove('show');
    }
  }

  // ---- Watchlist Management
  function saveWatchlist() {
    localStorage.setItem('eod-watchlist', JSON.stringify(watchlist));
  }

  function addSymbol() {
    const symbol = $('#new-symbol').value.trim().toUpperCase();
    // Validate symbol format (alphanumeric, dots, dashes only)
    if (symbol && /^[A-Z0-9\.\-]{1,10}$/.test(symbol) && !watchlist.includes(symbol)) {
      watchlist.push(symbol);
      saveWatchlist();
      updateWatchlistDisplay();
      $('#new-symbol').value = '';
    } else if (symbol && !watchlist.includes(symbol)) {
      log('Invalid symbol format. Use letters, numbers, dots, and dashes only.');
    }
  }

  function removeSymbol(symbol) {
    watchlist = watchlist.filter(s => s !== symbol);
    saveWatchlist();
    updateWatchlistDisplay();
    if (currentSymbol === symbol && watchlist.length > 0) {
      loadSymbol(watchlist[0]);
    }
  }

  function updateWatchlistDisplay() {
    const container = $('#watchlist');
    container.innerHTML = ''; // Clear existing content
    
    watchlist.forEach(symbol => {
      const item = document.createElement('div');
      item.className = `symbol-item ${symbol === currentSymbol ? 'active' : ''}`;
      item.dataset.symbol = symbol;
      
      const nameSpan = document.createElement('span');
      nameSpan.className = 'symbol-name';
      nameSpan.textContent = symbol; // Safe text content
      
      const removeBtn = document.createElement('button');
      removeBtn.className = 'remove-btn';
      removeBtn.textContent = 'Ã—';
      removeBtn.dataset.symbol = symbol;
      removeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        removeSymbol(e.target.dataset.symbol);
      });
      
      item.appendChild(nameSpan);
      item.appendChild(removeBtn);
      container.appendChild(item);
    });
  }

  function updateIndicatorToggles() {
    $('#ema-toggle').className = indicators.ema200 ? 'toggle-switch active' : 'toggle-switch';
    $('#bb-toggle').className = indicators.bb20 ? 'toggle-switch active' : 'toggle-switch';
  }

  function saveIndicators() {
    localStorage.setItem('eod-indicators', JSON.stringify(indicators));
  }

  function saveLevels() {
    localStorage.setItem('eod-levels', JSON.stringify(levels));
  }

  function saveTrendlines() {
    localStorage.setItem('eod-trendlines', JSON.stringify(trendlines));
  }

  function getTrendlinesForSymbol(symbol) {
    return trendlines[symbol] || [];
  }

  function addTrendline(startTime, startPrice, endTime, endPrice) {
    if (!trendlines[currentSymbol]) trendlines[currentSymbol] = [];
    const trendlineId = Date.now().toString();
    const trendline = {
      id: trendlineId,
      startTime: startTime,
      startPrice: startPrice,
      endTime: endTime,
      endPrice: endPrice,
      symbol: currentSymbol,
      color: '#f59e0b', // default color
      selected: false
    };
    trendlines[currentSymbol].push(trendline);
    saveTrendlines();
    updateTrendlinesDisplay();
    drawTrendlinesOnChart();
    return trendline;
  }

  function removeTrendline(trendlineId) {
    if (trendlines[currentSymbol]) {
      trendlines[currentSymbol] = trendlines[currentSymbol].filter(t => t.id !== trendlineId);
      saveTrendlines();
      updateTrendlinesDisplay();
      drawTrendlinesOnChart();
    }
  }

  function clearAllTrendlines() {
    if (trendlines[currentSymbol]) {
      trendlines[currentSymbol] = [];
      saveTrendlines();
      updateTrendlinesDisplay();
      drawTrendlinesOnChart();
    }
  }

  function getLevelsForSymbol(symbol) {
    return levels[symbol] || [];
  }

  function addLevel(price) {
    if (!levels[currentSymbol]) levels[currentSymbol] = [];
    const levelId = Date.now().toString();
    const level = {
      id: levelId,
      price: price,
      symbol: currentSymbol,
      color: '#60a5fa', // default color
      selected: false
    };
    levels[currentSymbol].push(level);
    saveLevels();
    updateLevelsDisplay();
    drawLevelsOnChart();
    return level;
  }

  function removeLevel(levelId) {
    if (levels[currentSymbol]) {
      levels[currentSymbol] = levels[currentSymbol].filter(l => l.id !== levelId);
      saveLevels();
      updateLevelsDisplay();
      drawLevelsOnChart();
    }
  }

  function clearAllLevels() {
    if (levels[currentSymbol]) {
      levels[currentSymbol] = [];
      saveLevels();
      updateLevelsDisplay();
      drawLevelsOnChart();
    }
  }

  function updateLevelsDisplay() {
    const container = $('#levels-list');
    container.innerHTML = '';
    
    const symbolLevels = getLevelsForSymbol(currentSymbol);
    symbolLevels.forEach(level => {
      const item = document.createElement('div');
      item.className = 'level-item';
      
      const priceSpan = document.createElement('span');
      priceSpan.className = 'level-price';
      priceSpan.textContent = level.price.toFixed(2);
      
      const controls = document.createElement('div');
      controls.className = 'level-controls';
      
      const deleteBtn = document.createElement('button');
      deleteBtn.textContent = 'Ã—';
      deleteBtn.title = 'Delete level';
      deleteBtn.addEventListener('click', () => removeLevel(level.id));
      
      controls.appendChild(deleteBtn);
      item.appendChild(priceSpan);
      item.appendChild(controls);
      container.appendChild(item);
    });
  }

  function updateTrendlinesDisplay() {
    // For now, we'll display trendlines in the levels list
    // A future enhancement could be a separate trendlines panel
  }

  function drawTrendlinesOnChart() {
    // Clear existing trendlines
    currentTrendlines.forEach(line => chart.removeSeries(line));
    currentTrendlines = [];
    
    // Draw current symbol's trendlines
    const symbolTrendlines = getTrendlinesForSymbol(currentSymbol);
    
    // Sanitize and validate trendlines before drawing
    const validTrendlines = symbolTrendlines.filter(t => 
      t && 
      t.startTime != null && 
      t.endTime != null && 
      Number.isFinite(t.startPrice) && 
      Number.isFinite(t.endPrice)
    );
    
    validTrendlines.forEach((trendline, index) => {
      try {
        const trendlineSeries = chart.addLineSeries({
          color: trendline.selected ? '#22d3ee' : (trendline.color || '#f59e0b'),
          lineWidth: trendline.selected ? 5 : 2, // Much thicker when selected
          lineStyle: 0
        });
        
        // Create line data with validated start and end points
        const lineData = [
          { time: trendline.startTime, value: trendline.startPrice },
          { time: trendline.endTime, value: trendline.endPrice }
        ];
        
        // Defensive check before setData
        if (lineData.every(point => point.time != null && Number.isFinite(point.value))) {
          trendlineSeries.setData(lineData);
          // Store reference to trendline data for selection
          trendlineSeries._trendlineData = trendline;
          trendlineSeries._trendlineIndex = index;
          currentTrendlines.push(trendlineSeries);
        } else {
          console.warn('[EOD] Skipped invalid trendline data:', lineData);
          chart.removeSeries(trendlineSeries);
        }
      } catch (error) {
        console.error('[EOD] Error drawing trendline:', error, trendline);
      }
    });
    
    // Clean up invalid trendlines from storage if we filtered any out
    if (validTrendlines.length !== symbolTrendlines.length) {
      if (!trendlines[currentSymbol]) trendlines[currentSymbol] = [];
      trendlines[currentSymbol] = validTrendlines;
      saveTrendlines();
      log(`Cleaned up ${symbolTrendlines.length - validTrendlines.length} invalid trendlines`);
    }
  }

  function drawLevelsOnChart() {
    // Clear existing level lines
    currentLevels.forEach(line => candleSeries.removePriceLine(line));
    currentLevels = [];
    
    // Draw current symbol's levels
    const symbolLevels = getLevelsForSymbol(currentSymbol);
    symbolLevels.forEach((level, index) => {
      const priceLine = {
        price: level.price,
        color: level.selected ? '#22d3ee' : (level.color || '#60a5fa'),
        lineWidth: level.selected ? 5 : 2, // Much thicker when selected
        lineStyle: 0, // solid line, thicker
        axisLabelVisible: true,
        title: `Level ${level.price.toFixed(2)}`
      };
      const line = candleSeries.createPriceLine(priceLine);
      line._levelData = level;
      line._levelIndex = index;
      currentLevels.push(line);
    });
  }

  // ---- Chart Interaction
  function setupChartInteraction() {
    chart.subscribeClick(param => {
      if (param.point) {
        const price = candleSeries.coordinateToPrice(param.point.y);
        const time = chart.timeScale().coordinateToTime(param.point.x);
        
        if (price !== null && !isNaN(price) && time !== null && time !== undefined) {
          // Check if clicking on existing line for selection (when not in drawing mode)
          if (!drawingMode) {
            const clickedLine = findLineNearClick(param.point.x, param.point.y);
            if (clickedLine) {
              selectLine(clickedLine);
              log(`Selected ${clickedLine.type} line`);
              return;
            } else {
              // Clicked on empty space - deselect any selected line
              deselectLine();
            }
          }
          
          // Handle drawing mode clicks
          if (drawingMode) {
            if (drawingTool === 'level') {
              addLevel(price);
              // Auto-disable drawing mode after adding level
              drawingMode = false;
              $('#level-tool').classList.remove('active');
              log(`Added level at ${price.toFixed(2)}`);
            } else if (drawingTool === 'trendline') {
              if (!trendlineStart) {
                // First click - set start point and enable preview
                trendlineStart = { time, price };
                enableTrendlinePreview();
                log('Click second point to complete trendline');
              } else {
                // Second click - complete trendline
                disableTrendlinePreview();
                addTrendline(trendlineStart.time, trendlineStart.price, time, price);
                log(`Added trendline from ${trendlineStart.price.toFixed(2)} to ${price.toFixed(2)}`);
                
                // Reset for next trendline
                trendlineStart = null;
                drawingMode = false;
                $('#trendline-tool').classList.remove('active');
              }
            }
          }
        }
      }
    });
    
    // Mouse move handler for live trendline preview
    chart.subscribeCrosshairMove(param => {
      if (drawingMode && drawingTool === 'trendline' && trendlineStart && param.point) {
        const price = candleSeries.coordinateToPrice(param.point.y);
        const time = chart.timeScale().coordinateToTime(param.point.x);
        
        if (price !== null && !isNaN(price) && time !== null && time !== undefined) {
          updateTrendlinePreview(time, price);
        }
      }
    });
  }
  
  function enableTrendlinePreview() {
    if (!previewTrendline) {
      previewTrendline = chart.addLineSeries({
        color: '#60a5fa',
        lineWidth: 1,
        lineStyle: 2, // dashed for preview
        priceLineVisible: false,
        lastValueVisible: false
      });
    }
  }
  
  function updateTrendlinePreview(endTime, endPrice) {
    if (previewTrendline && trendlineStart) {
      const lineData = [
        { time: trendlineStart.time, value: trendlineStart.price },
        { time: endTime, value: endPrice }
      ];
      previewTrendline.setData(lineData);
    }
  }
  
  function disableTrendlinePreview() {
    if (previewTrendline) {
      try {
        chart.removeSeries(previewTrendline);
      } catch (error) {
        console.log('[EOD] Preview series already removed or invalid');
      }
      previewTrendline = null;
    }
  }
  
  function findLineNearClick(x, y) {
    const tolerance = 8; // pixels
    
    // Check trendlines first
    for (let series of currentTrendlines) {
      if (series._trendlineData && isPointNearTrendline(x, y, series._trendlineData, tolerance)) {
        return {
          type: 'trendline',
          series: series,
          data: series._trendlineData,
          index: series._trendlineIndex
        };
      }
    }
    
    // Check levels
    const clickPrice = candleSeries.coordinateToPrice(y);
    const tolPrice = Math.abs(candleSeries.coordinateToPrice(y + tolerance) - candleSeries.coordinateToPrice(y));
    for (let i=0;i<currentLevels.length;i++) {
      const levelData = getLevelsForSymbol(currentSymbol)[i];
      if (levelData && Math.abs(clickPrice - levelData.price) < tolPrice) {
        return { type:'level', series: currentLevels[i], data: levelData, index: i };
      }
    }
    
    return null;
  }
  
  function isPointNearTrendline(x, y, trendlineData, tolerance) {
    // Convert trendline coordinates to pixels
    const startX = chart.timeScale().timeToCoordinate(trendlineData.startTime);
    const startY = candleSeries.priceToCoordinate(trendlineData.startPrice);
    const endX = chart.timeScale().timeToCoordinate(trendlineData.endTime);
    const endY = candleSeries.priceToCoordinate(trendlineData.endPrice);
    
    if (startX === null || startY === null || endX === null || endY === null) {
      return false;
    }
    
    // Calculate distance from point to line segment
    const distance = distanceToLineSegment(x, y, startX, startY, endX, endY);
    return distance <= tolerance;
  }
  
  function distanceToLineSegment(x, y, x1, y1, x2, y2) {
    const A = x - x1;
    const B = y - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;
    
    if (lenSq !== 0) {
      param = dot / lenSq;
    }
    
    let xx, yy;
    if (param < 0) {
      xx = x1;
      yy = y1;
    } else if (param > 1) {
      xx = x2;
      yy = y2;
    } else {
      xx = x1 + param * C;
      yy = y1 + param * D;
    }
    
    const dx = x - xx;
    const dy = y - yy;
    return Math.sqrt(dx * dx + dy * dy);
  }
  
  function selectLine(lineInfo) {
    // Clear previous selections
    getTrendlinesForSymbol(currentSymbol).forEach(t => t.selected = false);
    getLevelsForSymbol(currentSymbol).forEach(l => l.selected = false);

    selectedLine = lineInfo;
    isLineSelected = true;
    if (lineInfo.type === 'trendline') {
      lineInfo.data.selected = true;
      saveTrendlines();
      drawTrendlinesOnChart();
    } else if (lineInfo.type === 'level') {
      lineInfo.data.selected = true;
      saveLevels();
      drawLevelsOnChart();
    }
    showLineControls(lineInfo);
    updateLineHandles();
    log(`âœ… SELECTED ${lineInfo.type.toUpperCase()}: Click color buttons to change, X to delete, or drag handles to resize`);
  }

  function deselectLine() {
    if (!isLineSelected) return;
    getTrendlinesForSymbol(currentSymbol).forEach(t => t.selected = false);
    getLevelsForSymbol(currentSymbol).forEach(l => l.selected = false);
    saveTrendlines();
    saveLevels();
    drawTrendlinesOnChart();
    drawLevelsOnChart();
    selectedLine = null;
    isLineSelected = false;
    hideLineControls();
    clearLineHandles();
    log('âŒ Line deselected');
  }

  function showLineControls(lineInfo) {
    const panel = document.getElementById('line-controls');
    panel.style.display = 'block';
    panel.style.background = 'rgba(0, 0, 0, 0.9)';
    panel.style.border = '2px solid #22d3ee';
    panel.style.boxShadow = '0 4px 12px rgba(34, 211, 238, 0.5)';
    
    const curr = (lineInfo.data.color || (lineInfo.type==='trendline' ? '#f59e0b' : '#60a5fa'));
    document.querySelectorAll('.color-option').forEach(o => o.classList.toggle('active', o.dataset.color === curr));
    
    // Add selection title
    let title = panel.querySelector('.selection-title');
    if (!title) {
      title = document.createElement('div');
      title.className = 'selection-title';
      title.style.cssText = 'color: #22d3ee; font-weight: bold; margin-bottom: 8px; text-align: center; font-size: 14px;';
      panel.insertBefore(title, panel.firstChild);
    }
    title.textContent = `ðŸŽ¯ ${lineInfo.type.toUpperCase()} SELECTED`;
  }
  
  function hideLineControls() { 
    const panel = document.getElementById('line-controls');
    panel.style.display='none';
    panel.style.border = '1px solid #374151';
    panel.style.boxShadow = 'none';
  }
  
  function deleteSelectedLine() {
    if (!selectedLine) return;
    if (selectedLine.type==='trendline') removeTrendline(selectedLine.data.id);
    else removeLevel(selectedLine.data.id);
    deselectLine();
  }

  // Draggable handles for trendlines (fixed to prevent explosion)
  let dragState = { isDragging: false, handleElement: null, isStart: false };
  
  function updateLineHandles() {
    clearLineHandles();
    if (!selectedLine || selectedLine.type!=='trendline') return;
    const { startTime, startPrice, endTime, endPrice } = selectedLine.data;
    const p = document.getElementById('chart');
    
    const createHandle = (x, y, isStart) => { 
      if (x === null || y === null) return;
      const handle = document.createElement('div'); 
      handle.className = 'line-handle';
      handle.style.cssText = `
        position: absolute;
        width: 12px;
        height: 12px;
        border: 3px solid #22d3ee;
        border-radius: 50%;
        background: ${selectedLine.data.color || '#f59e0b'};
        transform: translate(-50%, -50%);
        cursor: grab;
        z-index: 1000;
        box-shadow: 0 2px 8px rgba(34, 211, 238, 0.6);
        pointer-events: auto;
      `;
      handle.style.left = x + 'px';
      handle.style.top = y + 'px';
      handle.dataset.isStart = isStart;
      
      // Simple click to drag - no complex event handling
      handle.addEventListener('mousedown', (e) => {
        dragState.isDragging = true;
        dragState.handleElement = handle;
        dragState.isStart = isStart;
        handle.style.cursor = 'grabbing';
        e.preventDefault();
        e.stopPropagation();
      });
      
      p.appendChild(handle); 
      lineHandles.push(handle); 
    };
    
    const sx = chart.timeScale().timeToCoordinate(startTime);
    const sy = candleSeries.priceToCoordinate(startPrice);
    const ex = chart.timeScale().timeToCoordinate(endTime);
    const ey = candleSeries.priceToCoordinate(endPrice);
    
    createHandle(sx, sy, true);  // Start handle
    createHandle(ex, ey, false); // End handle
  }
  
  // Global drag handlers (only one set of listeners)
  document.addEventListener('mousemove', (e) => {
    if (!dragState.isDragging || !dragState.handleElement) return;
    
    const p = document.getElementById('chart');
    const rect = p.getBoundingClientRect();
    const newX = e.clientX - rect.left;
    const newY = e.clientY - rect.top;
    
    // Update handle position visually
    dragState.handleElement.style.left = newX + 'px';
    dragState.handleElement.style.top = newY + 'px';
  });
  
  document.addEventListener('mouseup', () => {
    if (!dragState.isDragging) return;
    
    if (dragState.handleElement && selectedLine && dragState.handleElement.parentNode) {
      const p = document.getElementById('chart');
      const rect = p.getBoundingClientRect();
      const handleRect = dragState.handleElement.getBoundingClientRect();
      let newX = handleRect.left - rect.left + 6; // +6 for handle center
      let newY = handleRect.top - rect.top + 6;
      
      // Clamp coordinates to chart bounds
      newX = Math.max(0, Math.min(newX, rect.width));
      newY = Math.max(0, Math.min(newY, rect.height));
      
      const newTime = chart.timeScale().coordinateToTime(newX);
      const newPrice = candleSeries.coordinateToPrice(newY);
      
      if (newTime && newPrice && !isNaN(newTime) && !isNaN(newPrice)) {
        const trendlines = getTrendlinesForSymbol(currentSymbol);
        const trendlineIndex = trendlines.findIndex(t => t.id === selectedLine.data.id);
        if (trendlineIndex >= 0) {
          if (dragState.isStart) {
            trendlines[trendlineIndex].startTime = newTime;
            trendlines[trendlineIndex].startPrice = newPrice;
            selectedLine.data.startTime = newTime;
            selectedLine.data.startPrice = newPrice;
          } else {
            trendlines[trendlineIndex].endTime = newTime;
            trendlines[trendlineIndex].endPrice = newPrice;
            selectedLine.data.endTime = newTime;
            selectedLine.data.endPrice = newPrice;
          }
          saveTrendlines();
          drawTrendlinesOnChart();
          // Update handles to new position
          updateLineHandles();
          log('âœ… Trendline resized - new position saved');
        }
      } else {
        log('âš ï¸ Drag position out of bounds - trendline not moved');
      }
    }
    
    // Reset drag state and cursor
    if (dragState.handleElement && dragState.handleElement.parentNode) {
      dragState.handleElement.style.cursor = 'grab';
    }
    dragState = { isDragging: false, handleElement: null, isStart: false };
  });
  
  function clearLineHandles() { 
    // Reset cursor if actively dragging
    if (dragState.handleElement) {
      dragState.handleElement.style.cursor = 'grab';
    }
    
    lineHandles.forEach(h=>h.remove()); 
    lineHandles=[]; 
    
    // Completely reset drag state
    dragState = { isDragging: false, handleElement: null, isStart: false };
  }
  
  // Track chart viewport changes to keep handles synchronized
  function setupHandleTracking() {
    chart.timeScale().subscribeVisibleTimeRangeChange(() => {
      if (selectedLine && selectedLine.type === 'trendline') {
        updateLineHandles();
      }
    });
  }

  // ---- Event Listeners
  $('#add-btn').addEventListener('click', addSymbol);
  $('#new-symbol').addEventListener('keypress', e => e.key === 'Enter' && addSymbol());

  // Watchlist clicks
  $('#watchlist').addEventListener('click', e => {
    const item = e.target.closest('.symbol-item');
    if (item && !e.target.classList.contains('remove-btn')) {
      loadSymbol(item.dataset.symbol);
    }
  });

  // Indicator toggles
  $('#ema-toggle').addEventListener('click', () => {
    indicators.ema200 = !indicators.ema200;
    saveIndicators();
    updateIndicatorToggles();
    loadSymbol(currentSymbol); // refresh chart
  });

  $('#bb-toggle').addEventListener('click', () => {
    indicators.bb20 = !indicators.bb20;
    saveIndicators();
    updateIndicatorToggles();
    loadSymbol(currentSymbol); // refresh chart
  });

  // Drawing tool buttons
  $('#level-tool').addEventListener('click', () => {
    if (drawingTool === 'level' && drawingMode) {
      // Turn off drawing mode
      drawingMode = false;
      $('#level-tool').classList.remove('active');
      document.body.classList.remove('drawing-mode');
      log('Drawing mode off');
    } else {
      // Switch to level tool
      disableTrendlinePreview(); // Clean up any preview
      drawingMode = true;
      drawingTool = 'level';
      trendlineStart = null; // Reset trendline state
      $('#level-tool').classList.add('active');
      $('#trendline-tool').classList.remove('active');
      document.body.classList.add('drawing-mode');
      log('Click chart to add level');
    }
  });

  $('#trendline-tool').addEventListener('click', () => {
    if (drawingTool === 'trendline' && drawingMode) {
      // Turn off drawing mode
      drawingMode = false;
      trendlineStart = null;
      disableTrendlinePreview();
      $('#trendline-tool').classList.remove('active');
      document.body.classList.remove('drawing-mode');
      log('Drawing mode off');
    } else {
      // Switch to trendline tool
      disableTrendlinePreview(); // Clean up any existing preview
      drawingMode = true;
      drawingTool = 'trendline';
      trendlineStart = null;
      $('#trendline-tool').classList.add('active');
      $('#level-tool').classList.remove('active');
      document.body.classList.add('drawing-mode');
      log('Click chart to place first point of trendline');
    }
  });

  $('#clear-all').addEventListener('click', () => {
    if (confirm('Clear all levels and trendlines for ' + currentSymbol + '?')) {
      clearAllLevels();
      clearAllTrendlines();
      log('All levels and trendlines cleared');
    }
  });

  // Color picker and delete button event listeners
  document.getElementById('delete-line').addEventListener('click', deleteSelectedLine);
  document.querySelectorAll('.color-option').forEach(opt => {
    opt.addEventListener('click', () => {
      if (!selectedLine) return;
      const color = opt.dataset.color;
      selectedLine.data.color = color;
      if (selectedLine.type === 'trendline') { 
        saveTrendlines(); 
        drawTrendlinesOnChart(); 
      } else { 
        saveLevels(); 
        drawLevelsOnChart(); 
      }
      // Keep selection visible after redraw
      selectLine(selectedLine);
      log(`Changed line color to ${color}`);
    });
  });

  // Timeframe buttons (1D active, 1W/1M planned for Phase 3)
  $$('.timeframe-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      if (btn.dataset.tf === '1D') {
        $$('.timeframe-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        log('Daily timeframe selected');
      } else {
        log(`${btn.dataset.tf} aggregation planned for Phase 3`);
      }
    });
  });

  // ---- Initialize
  updateWatchlistDisplay();
  updateIndicatorToggles();
  updateLevelsDisplay();
  updateTrendlinesDisplay();
  setupChartInteraction();
  setupHandleTracking();
  loadSymbol(currentSymbol);

  // health check with status indicator
  fetch(`${API}/healthz`)
    .then(r => {
      if (r.ok) {
        log('Backend OK');
        $('#status-dot').className = 'status-dot status-connected';
      } else {
        log('Backend NOT OK');
        $('#status-dot').className = 'status-dot status-error';
      }
    })
    .catch(e => {
      log('Backend connection failed');
      $('#status-dot').className = 'status-dot status-error';
    });

  // removeSymbol no longer needs to be global (using event delegation)
})();
</script>
</body>
</html>
