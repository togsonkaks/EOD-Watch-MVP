<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>EOD Watch — Pro</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- TradingView Lightweight Charts -->
  <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    :root{--bg:#0e1a24;--panel:#0f1b2b;--border:#1f2937;--text:#cbd5e1;--muted:#94a3b8;--accent:#3b82f6;--good:#4ade80;--bad:#ef4444;--warn:#f59e0b}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    header{position:sticky;top:0;z-index:5;display:flex;gap:8px;align-items:center;padding:8px;border-bottom:1px solid var(--border);background:linear-gradient(#0f1b2b,#0e1a24)}
    input,button{background:#0b1522;border:1px solid #22314a;color:var(--text);border-radius:8px;padding:8px 10px}
    button{cursor:pointer}
    button.primary{background:var(--accent);border-color:var(--accent);color:white}
    .btn-toggle.active{outline:2px solid var(--accent)}
    .toolbar-sep{width:1px;height:24px;background:var(--border);margin:0 6px}
    main{display:grid;grid-template-columns:1fr 320px;gap:10px;padding:10px;height:calc(100% - 56px)}
    #board{grid-column:1/3;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:10px;margin-bottom:10px}
    #board-grid{display:grid;grid-template-columns:repeat(5,1fr);gap:8px}
    .mini{position:relative;background:#0f1b2b;border:1px solid var(--border);border-radius:8px;height:160px;overflow:hidden}
    .mini .title{position:absolute;left:6px;top:4px;font-size:12px;color:var(--muted)}
    .mini .enlarge{position:absolute;right:4px;top:4px;font-size:12px;padding:2px 6px;background:rgba(0,0,0,0.3);border-radius:4px;cursor:pointer}
    #chart{background:var(--panel);border:1px solid var(--border);border-radius:10px;min-height:520px;position:relative}
    .drawing-mode #chart { cursor: crosshair; }
    .loading-overlay { position:absolute; top:0; left:0; right:0; bottom:0; background:rgba(14,26,36,0.8); display:none; align-items:center; justify-content:center; color:#60a5fa; font-size:14px; border-radius:10px; }
    .loading-overlay.show { display:flex; }
    aside{background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:10px;display:flex;flex-direction:column;gap:10px;overflow:auto}
    h3{margin:.25rem 0 .5rem 0;font-size:13px;color:var(--muted)}
    .list .row{display:flex;justify-content:space-between;align-items:center;padding:4px 0;border-bottom:1px dashed #20304a}
    .row:hover{background:#0f1724}
    .row.selected{background:#1e3a8a20;border-left:3px solid #3b82f6}
    
    /* Enhanced level styling */
    .level-item .level-content{display:flex;align-items:center;gap:8px;flex:1}
    .level-price{font-weight:500}
    .level-color{width:12px;height:12px;border-radius:50%;border:1px solid #374151}
    
    /* Enhanced trendline styling */
    .trendline-item .trendline-content{display:flex;flex-direction:column;gap:2px;flex:1}
    .trendline-dates{font-size:11px;color:#64748b}
    .trendline-prices{font-size:12px;font-weight:500}
    .trendline-color{width:12px;height:3px;border-radius:2px;align-self:flex-start;margin-top:2px}
    
    .kill{background:transparent;border:none;color:#f87171;cursor:pointer;font-size:16px}
    .status{font:12px ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:#0b1524;border:1px solid #22314a;border-radius:8px;padding:8px;white-space:pre-wrap;min-height:38px}
    .chips{display:flex;gap:6px;flex-wrap:wrap}
    .chip{padding:3px 6px;border-radius:999px;border:1px solid var(--border);font-size:12px}
    .chip.good{border-color:#236a4d;color:#9ce8c0}
    .chip.bad{border-color:#632828;color:#f3b0b0}
    .chip.warn{border-color:#5a4517;color:#f6d399}

    /* Watchlist styles (enhanced) */
    #watchlist-section { background:var(--panel); border:1px solid var(--border); border-radius:10px; padding:10px; margin-bottom:10px; }
    #add-symbol { display:flex; gap:4px; margin-bottom:8px; }
    #new-symbol { flex:1; }
    .symbol-item { padding:8px; cursor:pointer; border-bottom:1px dashed #20304a; display:flex; justify-content:space-between; align-items:center; border-radius:4px; margin-bottom:2px; }
    .symbol-item:hover { background:#1e293b; }
    .symbol-item.active { background:var(--accent); color:white; }
    .symbol-name { font-weight:500; }
    .remove-btn { background:var(--bad); font-size:12px; padding:2px 6px; border-radius:3px; border:none; color:white; }

    /* Watchlist Board - Mini Chart Dashboard */
    #watchlist-board-section { background:var(--panel); border:1px solid var(--border); border-radius:10px; padding:10px; margin-bottom:10px; }
    #watchlist-board { display:grid; grid-template-columns:repeat(auto-fit, minmax(200px, 1fr)); gap:8px; margin-top:10px; }
    .mini-chart-container { 
      background:var(--surface); border:1px solid var(--border); border-radius:8px; padding:8px; 
      cursor:pointer; transition:all 0.2s ease; position:relative; min-height:120px;
    }
    .mini-chart-container:hover { border-color:var(--accent); box-shadow:0 2px 8px rgba(59,130,246,0.2); }
    .mini-chart-container.active { border-color:var(--accent); background:rgba(59,130,246,0.1); }
    .mini-chart-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; }
    .mini-chart-symbol { font-weight:bold; font-size:12px; color:var(--text); }
    .mini-chart-price { font-size:11px; color:var(--text-muted); }
    .mini-chart-change { font-size:10px; font-weight:bold; }
    .mini-chart-change.positive { color:#10b981; }
    .mini-chart-change.negative { color:#ef4444; }
    .mini-chart { width:100%; height:80px; }
    .mini-chart-loading { 
      display:flex; align-items:center; justify-content:center; height:80px; 
      color:var(--text-muted); font-size:11px; 
    }

    /* Enhanced Drawing Tools */
    .tool-section { background:var(--panel); border:1px solid var(--border); border-radius:10px; padding:10px; margin-bottom:10px; }
    .tool-btn { background:#374151; color:var(--text); border:0; border-radius:6px; padding:6px 12px; font-size:12px; cursor:pointer; margin-right:6px; margin-bottom:4px; }
    .tool-btn.active { background:var(--accent); box-shadow:0 0 8px rgba(59,130,246,0.4); }
    .tool-btn:hover { transform:translateY(-1px); transition:transform 0.1s; }

    /* Enhanced Indicators */
    .indicator-toggle { display:flex; align-items:center; gap:8px; margin-bottom:6px; font-size:12px; }
    .toggle-switch { width:36px; height:18px; background:#374151; border-radius:10px; position:relative; cursor:pointer; transition:background 0.2s; }
    .toggle-switch.active { background:var(--accent); }
    .toggle-knob { width:14px; height:14px; background:#fff; border-radius:50%; position:absolute; top:2px; left:2px; transition:left 0.2s; }
    .toggle-switch.active .toggle-knob { left:20px; }

    /* Modal */
    #modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,.84);z-index:50;align-items:center;justify-content:center}
    #modal .box{position:relative;width:92vw;height:86vh;background:var(--panel);border:1px solid var(--border);border-radius:10px;overflow:hidden}
    #modal .close{position:absolute;right:10px;top:8px;z-index:2;background:var(--bad);color:white;border:none;border-radius:4px;padding:4px 8px;cursor:pointer}

    /* Status indicators */
    .status-dot { width:8px; height:8px; border-radius:50%; margin-right:6px; }
    .status-connected { background:var(--good); }
    .status-loading { background:var(--warn); animation:pulse 1.5s infinite; }
    .status-error { background:var(--bad); }
    @keyframes pulse { 0%, 100% { opacity:1; } 50% { opacity:0.5; } }

    /* Line Controls (enhanced) */
    #line-controls { display:none; margin-top:10px; }
    .color-picker { display:flex; gap:6px; margin:6px 0; }
    .color-option { width:24px; height:24px; border-radius:6px; cursor:pointer; border:2px solid transparent; transition:transform 0.1s; }
    .color-option.active { border-color:var(--accent); }
    .color-option:hover { transform:scale(1.1); }

    /* Responsive */
    @media (max-width: 1200px) {
      main { grid-template-columns:1fr 280px; }
      #board-grid { grid-template-columns:repeat(4,1fr); }
    }
    @media (max-width: 900px) {
      main { grid-template-columns:1fr; }
      aside { order:-1; }
      #board { display:none; }
    }

    /* Alert Modal Styles */
    .alert-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .alert-modal-content {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 0;
      min-width: 320px;
      max-width: 420px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }

    .alert-modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
    }

    .alert-modal-header h3 {
      margin: 0;
      color: var(--text);
      font-size: 16px;
      font-weight: 600;
    }

    .alert-modal-close {
      background: none;
      border: none;
      color: var(--muted);
      font-size: 20px;
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      line-height: 1;
    }

    .alert-modal-close:hover {
      background: var(--border);
      color: var(--text);
    }

    .alert-modal-body {
      padding: 20px;
    }

    .alert-info {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 16px;
      color: var(--muted);
      font-size: 13px;
    }

    .alert-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .alert-btn {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 16px;
      border: 1px solid var(--border);
      border-radius: 8px;
      background: var(--bg);
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 14px;
      width: 100%;
    }

    .alert-btn:hover {
      border-color: var(--accent);
      background: rgba(59, 130, 246, 0.1);
    }

    .alert-btn-green:hover {
      border-color: var(--good);
      background: rgba(74, 222, 128, 0.1);
    }

    .alert-btn-red:hover {
      border-color: var(--bad);
      background: rgba(239, 68, 68, 0.1);
    }

    .alert-icon {
      font-size: 16px;
      font-weight: bold;
    }

    .alert-text {
      flex: 1;
      font-weight: 500;
    }

    .alert-price {
      font-weight: 600;
      color: var(--accent);
    }
  </style>
</head>
<body>
  <header>
    <input id="ticker" placeholder="AAPL" value="AAPL" />
    <button id="btnLoad" class="primary">Load</button>
    <div class="toolbar-sep"></div>
    <button class="tf btn-toggle" data-tf="4H">4H</button>
    <button class="tf btn-toggle active" data-tf="1D">1D</button>
    <button class="tf btn-toggle" data-tf="1W">1W</button>
    <button class="tf btn-toggle" data-tf="1M">1M</button>
    <div class="toolbar-sep"></div>
    <button id="toolLevel" class="btn-toggle">+ Level</button>
    <button id="toolTrend" class="btn-toggle">+ Trend (2-click)</button>
    <div class="toolbar-sep"></div>
    <button id="toggleEMA" class="btn-toggle">EMA200</button>
    <button id="toggleBB" class="btn-toggle">BB(20,2)</button>
    <div class="toolbar-sep"></div>
    <div id="testbox" style="display:flex; gap:6px; align-items:center;">
      <span style="opacity:.7">Test Mode:</span>
      <button id="testStart">Start</button>
      <button id="testStep">Step</button>
      <button id="testStop">Stop</button>
      <button id="testReset">Reset</button>
    </div>
    <div class="toolbar-sep"></div>
    <div style="display:flex; align-items:center;">
      <div class="status-dot status-connected" id="status-dot"></div>
      <span id="topStatus" style="margin-left:6px;color:var(--muted)">Ready</span>
    </div>
  </header>

  <main>
    <!-- 10-chart board -->
    <section id="board">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
        <div style="color:var(--muted);font-size:13px">WATCHLIST BOARD</div>
        <div id="boardHint" style="color:var(--muted);font-size:12px">Click mini to load main · ⤢ to enlarge</div>
      </div>
      <div id="board-grid"></div>
    </section>

    <!-- main chart -->
    <section id="chart">
      <div class="loading-overlay" id="loading-overlay">
        <div>Loading chart data...</div>
      </div>
    </section>

    <!-- side panel -->
    <aside>
      <div id="watchlist-section">
        <h3>WATCHLIST</h3>
        <div id="add-symbol">
          <input id="new-symbol" placeholder="Add symbol..." />
          <button id="add-btn">+</button>
        </div>
        <div id="watchlist"></div>
      </div>

      <div id="watchlist-board-section">
        <h3>MARKET BOARD</h3>
        <div id="watchlist-board"></div>
      </div>

      <div class="tool-section">
        <h3>INDICATORS</h3>
        <div class="indicator-toggle">
          <div class="toggle-switch active" id="ema-toggle">
            <div class="toggle-knob"></div>
          </div>
          <span>EMA(200)</span>
        </div>
        <div class="indicator-toggle">
          <div class="toggle-switch" id="bb-toggle">
            <div class="toggle-knob"></div>
          </div>
          <span>BB(20,2)</span>
        </div>
      </div>

      <div class="tool-section">
        <h3>DRAWING TOOLS</h3>
        <button class="tool-btn" id="level-tool">Level</button>
        <button class="tool-btn" id="trendline-tool">Trendline</button>
        <button class="tool-btn" id="clear-all">Clear All</button>
        
        <div id="line-controls">
          <h3>LINE OPTIONS</h3>
          <div class="color-picker">
            <div class="color-option" style="background:#60a5fa" data-color="#60a5fa" title="Blue"></div>
            <div class="color-option" style="background:#f59e0b" data-color="#f59e0b" title="Orange"></div>
            <div class="color-option" style="background:#10b981" data-color="#10b981" title="Green"></div>
            <div class="color-option" style="background:#ef4444" data-color="#ef4444" title="Red"></div>
            <div class="color-option" style="background:#8b5cf6" data-color="#8b5cf6" title="Purple"></div>
            <div class="color-option" style="background:#f97316" data-color="#f97316" title="Yellow"></div>
          </div>
          <button class="tool-btn" id="delete-line" style="background:var(--bad); width:100%; margin-top:4px;">Delete Selected Line</button>
        </div>
      </div>

      <div>
        <h3>Signals</h3>
        <div id="chips" class="chips"></div>
      </div>
      
      <div>
        <h3>Levels</h3>
        <div id="levels" class="list"></div>
      </div>
      
      <div>
        <h3>Trendlines</h3>
        <div id="trends" class="list"></div>
      </div>
      
      <div>
        <h3>Log</h3>
        <div id="log" class="status">—</div>
      </div>
    </aside>
  </main>

  <!-- fullscreen modal -->
  <div id="modal">
    <div class="box">
      <button class="close">✕</button>
      <div id="modalCanvas" style="position:absolute;inset:0"></div>
    </div>
  </div>

  <!-- Alert Setup Modal -->
  <div id="alert-modal" class="alert-modal" style="display: none;">
    <div class="alert-modal-content">
      <div class="alert-modal-header">
        <h3 id="alert-modal-title">Set Alert</h3>
        <span class="alert-modal-close" onclick="closeAlertModal()">&times;</span>
      </div>
      <div class="alert-modal-body">
        <div id="alert-line-info" class="alert-info"></div>
        <div class="alert-options">
          <div class="alert-option">
            <button id="alert-above-btn" class="alert-btn alert-btn-green" onclick="setAlertDirection('above')">
              <span class="alert-icon">▲</span>
              <span class="alert-text">Close Above</span>
              <span id="alert-above-price" class="alert-price"></span>
            </button>
          </div>
          <div class="alert-option">
            <button id="alert-below-btn" class="alert-btn alert-btn-red" onclick="setAlertDirection('below')">
              <span class="alert-icon">▼</span>
              <span class="alert-text">Close Below</span>
              <span id="alert-below-price" class="alert-price"></span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(function () {
  const API = ''; // same origin
  const $ = s => document.querySelector(s);
  const $$ = s => document.querySelectorAll(s);
  const log = m => { $('#log').textContent = m; console.log('[EOD]', m); };

  // ---- Application State with safe migration
  // One-time migration cleanup (only run once to prevent data loss)
  const migrationVersion = localStorage.getItem('eod-migration-version');
  if (!migrationVersion || migrationVersion < '2.0') {
    console.log('[EOD] Running one-time migration - upgrading data format');
    localStorage.removeItem('eod-levels');
    localStorage.removeItem('eod-trendlines');
    localStorage.setItem('eod-migration-version', '2.0');
  }

  // Global state for signal detection system
  let tfBars = [];  // Current timeframe bars for signal evaluation
  
  let watchlist = JSON.parse(localStorage.getItem('eod-watchlist') || '["AAPL", "META", "TSLA", "GOOGL", "MSFT"]');
  let currentSymbol = localStorage.getItem('eod-current-symbol') || 'AAPL';
  let currentTimeframe = localStorage.getItem('eod-current-timeframe') || '1D';
  let indicators = JSON.parse(localStorage.getItem('eod-indicators') || '{"ema200": true, "bb20": false}');
  let dailyBars = []; // Store raw daily data for resampling
  let levels = {}; // Start fresh - now organized by symbol+timeframe
  let trendlines = {}; // Start fresh - now organized by symbol+timeframe
  let drawingMode = false;
  let drawingTool = 'level'; // 'level' or 'trendline'
  let trendlineStart = null; // for 2-point trendline drawing
  let previewTrendline = null; // preview line while drawing
  let previewUpdateThrottle = null; // throttle preview updates for performance
  // ==== OPTIMIZED CACHES FOR BUTTERY SMOOTH PERFORMANCE ====
  const trendSeriesById = new Map(); // id -> { series, data }
  const levelLineById = new Map(); // id -> { line, data }
  let currentLevels = []; // keep for compatibility
  let currentTrendlines = []; // keep for compatibility
  let selectedLine = null; // currently selected line for editing
  let lineHandles = []; // visual handles for selected line
  let isLineSelected = false; // flag to track selection state
  
  // ==== OPTIMIZED DRAG STATES ====
  let levelDragState = { isDragging: false, id: null };
  let trendDragState = { 
    isDragging: false, 
    id: null, 
    mode: null, // 'move' | 'start' | 'end'
    base: { time: 0, price: 0 }, 
    start: { time: 0, price: 0 }, 
    end: { time: 0, price: 0 } 
  };
  
  // ==== SINGLE RAF LOOP FOR 60FPS SMOOTH UPDATES ====
  let rafToken = null;
  let lastPointer = null;

  // ==== SCREEN-SPACE HIT TESTING FOR RELIABLE LINE SELECTION ====
  function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }
  function clamp01(t){ return t<0?0:t>1?1:t; }
  function pointSegDist(px,py, x1,y1, x2,y2){
    const A={x:x1,y:y1}, B={x:x2,y:y2}, P={x:px,y:py};
    const AB={x:B.x-A.x, y:B.y-A.y};
    const t = clamp01(((P.x-A.x)*AB.x + (P.y-A.y)*AB.y) / (AB.x*AB.x + AB.y*AB.y || 1));
    const proj = { x: A.x + t*AB.x, y: A.y + t*AB.y };
    return Math.sqrt(dist2(P, proj));
  }

  function hitTestTrendlines(px, py, tolerancePx = 10){
    for (const [id, rec] of trendSeriesById.entries()){
      const t = rec.data;
      const x1 = chart.timeScale().timeToCoordinate(t.startTime);
      const y1 = candleSeries.priceToCoordinate(t.startPrice);
      const x2 = chart.timeScale().timeToCoordinate(t.endTime);
      const y2 = candleSeries.priceToCoordinate(t.endPrice);
      if ([x1,y1,x2,y2].some(v => v == null)) continue;
      const d = pointSegDist(px, py, x1,y1,x2,y2);
      if (d <= tolerancePx) return { id, where: d < 8 ? 'segment' : 'near' };
    }
    return null;
  }

  function hitTestLevel(px, py, tolerancePx = 8){
    for (const [id, rec] of levelLineById.entries()){
      const y = candleSeries.priceToCoordinate(rec.data.price);
      if (y == null) continue;
      if (Math.abs(py - y) <= tolerancePx) return { id };
    }
    return null;
  }

  // ==== PERFORMANCE FREEZING DURING DRAG ====
  function freezeDuringDrag(on) {
    chart.applyOptions({
      crosshair: { mode: on ? LightweightCharts.CrosshairMode.Hidden : LightweightCharts.CrosshairMode.Magnet },
      rightPriceScale: { autoScale: !on }
    });
  }

  // ==== BUTTERY SMOOTH POINTER EVENT SYSTEM ====
  let pointerDownState = {
    startX: 0,
    startY: 0,
    startTime: 0,
    isDragging: false,
    hasMoved: false,
    pendingDrag: null
  };

  function onPointerDown(e) {
    const chartContainer = document.getElementById('chart');
    chartContainer.setPointerCapture(e.pointerId);
    
    const rect = chartContainer.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;
    
    // Record initial position and time for click vs drag detection
    pointerDownState = {
      startX: px,
      startY: py,
      startTime: Date.now(),
      isDragging: false,
      hasMoved: false,
      pendingDrag: null
    };
    
    // DON'T freeze performance yet - wait for drag threshold
    // freezeDuringDrag(true); // MOVED TO DRAG THRESHOLD
    
    // Use screen-space hit testing for reliable selection
    const trendlineHit = hitTestTrendlines(px, py);
    const levelHit = hitTestLevel(px, py);
    
    if (trendlineHit) {
      const t = trendSeriesById.get(trendlineHit.id)?.data;
      if (t) {
        const time = chart.timeScale().coordinateToTime(px);
        const price = candleSeries.coordinateToPrice(py);
        
        // Check if clicking near endpoints for resize
        const x1 = chart.timeScale().timeToCoordinate(t.startTime);
        const y1 = candleSeries.priceToCoordinate(t.startPrice);
        const x2 = chart.timeScale().timeToCoordinate(t.endTime);
        const y2 = candleSeries.priceToCoordinate(t.endPrice);
        
        const startDist = Math.hypot(px - x1, py - y1);
        const endDist = Math.hypot(px - x2, py - y2);
        
        // DON'T set isDragging=true yet - store pending drag info
        if (startDist <= 12) {
          pointerDownState.pendingDrag = {
            type: 'trendline', id: trendlineHit.id, mode: 'start',
            base: { time, price }, start: { time: t.startTime, price: t.startPrice },
            end: { time: t.endTime, price: t.endPrice }
          };
        } else if (endDist <= 12) {
          pointerDownState.pendingDrag = {
            type: 'trendline', id: trendlineHit.id, mode: 'end',
            base: { time, price }, start: { time: t.startTime, price: t.startPrice },
            end: { time: t.endTime, price: t.endPrice }
          };
        } else {
          pointerDownState.pendingDrag = {
            type: 'trendline', id: trendlineHit.id, mode: 'move',
            base: { time, price }, start: { time: t.startTime, price: t.startPrice },
            end: { time: t.endTime, price: t.endPrice }
          };
        }
        
        chartContainer.style.cursor = pointerDownState.pendingDrag.mode === 'move' ? 'grab' : 'nw-resize';
        e.preventDefault();
        e.stopPropagation();
      }
    } else if (levelHit) {
      // Store pending level drag (don't set isDragging yet)
      pointerDownState.pendingDrag = { type: 'level', id: levelHit.id };
      chartContainer.style.cursor = 'ns-resize';
      e.preventDefault();
      e.stopPropagation();
    }
  }

  function onPointerMove(e) {
    lastPointer = e; // stash the latest event
    
    // Track movement for click vs drag detection
    if (pointerDownState && !pointerDownState.isDragging && pointerDownState.pendingDrag) {
      const rect = document.getElementById('chart').getBoundingClientRect();
      const px = e.clientX - rect.left;
      const py = e.clientY - rect.top;
      
      const deltaX = Math.abs(px - pointerDownState.startX);
      const deltaY = Math.abs(py - pointerDownState.startY);
      const totalMovement = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
      
      // If movement exceeds threshold, activate drag mode
      if (totalMovement > 5) {
        pointerDownState.isDragging = true;
        pointerDownState.hasMoved = true;
        
        // Activate the pending drag based on type
        if (pointerDownState.pendingDrag.type === 'trendline') {
          trendDragState = {
            isDragging: true,
            id: pointerDownState.pendingDrag.id,
            mode: pointerDownState.pendingDrag.mode,
            base: pointerDownState.pendingDrag.base,
            start: pointerDownState.pendingDrag.start,
            end: pointerDownState.pendingDrag.end
          };
        } else if (pointerDownState.pendingDrag.type === 'level') {
          levelDragState = { 
            isDragging: true, 
            id: pointerDownState.pendingDrag.id 
          };
        }
        
        // NOW start performance freezing for drag
        freezeDuringDrag(true);
      }
    }
    
    if (rafToken) return; // already queued
    rafToken = requestAnimationFrame(processPointer);
  }

  function processPointer() {
    rafToken = null;
    if (!lastPointer) return;

    const rect = document.getElementById('chart').getBoundingClientRect();
    const px = lastPointer.clientX - rect.left;
    const py = lastPointer.clientY - rect.top;

    // Convert once per frame
    const time = chart.timeScale().coordinateToTime(px);
    const price = candleSeries.coordinateToPrice(py);

    // Only process drags if we've exceeded the threshold
    if (!pointerDownState.isDragging) return;

    // 1) drag level
    if (levelDragState.isDragging && levelDragState.id && Number.isFinite(price) && price > 0) {
      const levels = getLevelsForSymbol(currentSymbol, currentTimeframe);
      const i = levels.findIndex(L => L.id === levelDragState.id);
      if (i >= 0 && levels[i].price !== price) {
        levels[i].price = price; // update model
        // update only that line (recreate just 1 priceLine)
        const rec = levelLineById.get(levelDragState.id);
        if (rec) {
          try { candleSeries.removePriceLine(rec.line); } catch {}
          const line = candleSeries.createPriceLine({
            price,
            color: levels[i].selected ? '#22d3ee' : (levels[i].color || '#60a5fa'),
            lineWidth: levels[i].selected ? 5 : 2,
            lineStyle: 0, axisLabelVisible: true, title: `Level ${price.toFixed(2)}`
          });
          levelLineById.set(levelDragState.id, { line, data: levels[i] });
        }
      }
    }

    // 2) drag trendline
    if (trendDragState.isDragging && trendDragState.id && time != null && Number.isFinite(price)) {
      const arr = getTrendlinesForSymbol(currentSymbol, currentTimeframe);
      const idx = arr.findIndex(t => t.id === trendDragState.id);
      if (idx >= 0) {
        const t = arr[idx];
        if (trendDragState.mode === 'move') {
          const dt = time - trendDragState.base.time;
          const dp = price - trendDragState.base.price;
          t.startTime = trendDragState.start.time + dt;
          t.startPrice = trendDragState.start.price + dp;
          t.endTime = trendDragState.end.time + dt;
          t.endPrice = trendDragState.end.price + dp;
        } else if (trendDragState.mode === 'start') {
          t.startTime = time; t.startPrice = price;
        } else if (trendDragState.mode === 'end') {
          t.endTime = time; t.endPrice = price;
        }
        const rec = trendSeriesById.get(trendDragState.id);
        if (rec) {
          rec.data = t; // keep cache in sync
          rec.series.setData([
            { time: t.startTime, value: t.startPrice },
            { time: t.endTime, value: t.endPrice },
          ]);
        }
      }
    }
  }

  function onPointerUp(e) {
    const chartContainer = document.getElementById('chart');
    try { chartContainer.releasePointerCapture(e.pointerId); } catch {}
    
    // Stop performance freezing
    freezeDuringDrag(false);
    
    const rect = chartContainer.getBoundingClientRect();
    const px = e.clientX - rect.left;
    const py = e.clientY - rect.top;
    
    // Check if this was a click vs drag
    const duration = Date.now() - pointerDownState.startTime;
    const deltaX = Math.abs(px - pointerDownState.startX);
    const deltaY = Math.abs(py - pointerDownState.startY);
    const totalMovement = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    
    const wasClick = !pointerDownState.hasMoved && 
                     totalMovement < 5 && 
                     duration < 300 && 
                     !drawingMode;
    
    if (wasClick) {
      // HANDLE CLICK - Check for alert setup
      const time = chart.timeScale().coordinateToTime(px);
      const price = candleSeries.coordinateToPrice(py);
      
      if (time && price) {
        // Check for line clicks first
        const trendlineHit = hitTestTrendlines(px, py);
        const levelHit = hitTestLevel(px, py);
        
        if (trendlineHit) {
          const t = trendSeriesById.get(trendlineHit.id)?.data;
          if (t) {
            // Calculate current price on trendline at click time
            const trendPrice = calculateTrendlinePrice(t, time);
            openAlertModal({
              type: 'trendline',
              id: trendlineHit.id,
              price: trendPrice,
              trendlineData: t
            });
            log(`Alert setup for trendline`);
          }
        } else if (levelHit) {
          const level = levelLineById.get(levelHit.id)?.data;
          if (level) {
            openAlertModal({
              type: 'level',
              id: levelHit.id,
              price: level.price,
              trendlineData: null
            });
            log(`Alert setup for level at $${level.price.toFixed(2)}`);
          }
        } else {
          // Check for indicator clicks
          const indicatorClick = detectIndicatorClick(px, py);
          if (indicatorClick) {
            openAlertModal(indicatorClick);
            log(`Alert setup for ${indicatorClick.type}`);
          }
        }
      }
      
      // Reset pointer state after click
      pointerDownState = { startX: 0, startY: 0, startTime: 0, isDragging: false, hasMoved: false, pendingDrag: null };
      lastPointer = null;
      chartContainer.style.cursor = '';
      return;
    }
    
    // HANDLE DRAG END - finalize: save to storage, rebuild handles once, clear drag states
    if (levelDragState.isDragging) {
      levelDragState = { isDragging: false, id: null };
      saveLevelsForSymbol(currentSymbol, currentTimeframe, getLevelsForSymbol(currentSymbol, currentTimeframe));
      updateLineHandles();
      evaluateCurrentSignals(); // Update signals after level drag
    }
    if (trendDragState.isDragging) {
      trendDragState.isDragging = false;
      saveTrendlinesForSymbol(currentSymbol, currentTimeframe, getTrendlinesForSymbol(currentSymbol, currentTimeframe));
      updateLineHandles();
      evaluateCurrentSignals(); // Update signals after trendline drag
    }
    
    // Reset ALL pointer state
    pointerDownState = { startX: 0, startY: 0, startTime: 0, isDragging: false, hasMoved: false, pendingDrag: null };
    lastPointer = null;
    chartContainer.style.cursor = '';
  }

  // ---- Chart init
  const chart = LightweightCharts.createChart(document.getElementById('chart'), {
    autoSize: true,
    layout: { background: { color: '#0e1a24' }, textColor: '#cbd5e1' },
    grid: { vertLines: { color: '#1f2937' }, horzLines: { color: '#1f2937' } },
    rightPriceScale: { borderColor: '#334155' },
    timeScale: { borderColor: '#334155' }
  });
  const candleSeries = chart.addCandlestickSeries();
  // indicators
  const emaSeries = chart.addLineSeries({ color: '#60a5fa', lineWidth: 2 });
  const bbUpperSeries = chart.addLineSeries({ color: '#f59e0b', lineWidth: 1 });
  const bbMiddleSeries = chart.addLineSeries({ color: '#f59e0b', lineWidth: 1, lineStyle: 2 });
  const bbLowerSeries = chart.addLineSeries({ color: '#f59e0b', lineWidth: 1 });

  // ---- Indicator calculations
  function ema(values, period) {
    if (values.length === 0) return [];
    const k = 2 / (period + 1);
    let emaVal = values[0].close;
    const out = [{ time: values[0].time, value: emaVal }];
    for (let i = 1; i < values.length; i++) {
      emaVal = values[i].close * k + emaVal * (1 - k);
      out.push({ time: values[i].time, value: emaVal });
    }
    return out;
  }

  function bollingerBands(values, period, stdDev) {
    if (!values || values.length < period) return { upper: [], middle: [], lower: [] };
    
    const upper = [], middle = [], lower = [];
    
    for (let i = period - 1; i < values.length; i++) {
      // Calculate SMA for middle band
      const slice = values.slice(i - period + 1, i + 1);
      
      // Ensure all values are valid numbers
      const validSlice = slice.filter(bar => bar && typeof bar.close === 'number' && !isNaN(bar.close));
      if (validSlice.length !== slice.length) continue; // Skip if any invalid data
      
      const sma = validSlice.reduce((sum, bar) => sum + bar.close, 0) / validSlice.length;
      
      // Calculate standard deviation
      const variance = validSlice.reduce((sum, bar) => sum + Math.pow(bar.close - sma, 2), 0) / validSlice.length;
      const std = Math.sqrt(variance);
      
      const time = values[i].time;
      if (time && !isNaN(sma) && !isNaN(std)) {
        middle.push({ time, value: sma });
        upper.push({ time, value: sma + (stdDev * std) });
        lower.push({ time, value: sma - (stdDev * std) });
      }
    }
    
    return { upper, middle, lower };
  }

  // Weekly resampling (aggregates daily bars to weekly candles)
  function resampleWeekly(daily) {
    if (!daily || !daily.length) return [];
    
    const weekly = [];
    let currentWeek = null;
    let weekData = null;
    
    // Helper function to get ISO week number
    function getISOWeek(timestamp) {
      const date = new Date(timestamp * 1000);
      date.setUTCHours(0, 0, 0, 0);
      const dayOfWeek = (date.getUTCDay() + 6) % 7; // Monday = 0
      date.setUTCDate(date.getUTCDate() - dayOfWeek + 3); // Thursday of current week
      const firstThursday = new Date(Date.UTC(date.getUTCFullYear(), 0, 4));
      const weekNumber = 1 + Math.round(((date - firstThursday) / 86400000 - 3 + ((firstThursday.getUTCDay() + 6) % 7)) / 7);
      return date.getUTCFullYear() + "-" + weekNumber;
    }
    
    for (const bar of daily) {
      if (!bar || typeof bar.time !== 'number') continue;
      
      const week = getISOWeek(bar.time);
      
      if (week !== currentWeek) {
        // Start new week
        if (weekData) weekly.push(weekData);
        weekData = {
          time: bar.time,
          open: bar.open,
          high: bar.high,
          low: bar.low,
          close: bar.close
        };
        currentWeek = week;
      } else {
        // Update current week data
        weekData.high = Math.max(weekData.high, bar.high);
        weekData.low = Math.min(weekData.low, bar.low);
        weekData.close = bar.close; // Last close of the week
      }
    }
    
    // Add final week
    if (weekData) weekly.push(weekData);
    
    return weekly;
  }

  // Monthly resampling (aggregates daily bars to monthly candles)
  function resampleMonthly(daily) {
    if (!daily || !daily.length) return [];
    
    const monthly = [];
    let currentMonth = null;
    let monthData = null;
    
    // Helper function to get year-month key
    function getYearMonth(timestamp) {
      const date = new Date(timestamp * 1000);
      return date.getUTCFullYear() + "-" + String(date.getUTCMonth() + 1).padStart(2, '0');
    }
    
    for (const bar of daily) {
      if (!bar || typeof bar.time !== 'number') continue;
      
      const month = getYearMonth(bar.time);
      
      if (month !== currentMonth) {
        // Start new month
        if (monthData) monthly.push(monthData);
        monthData = {
          time: bar.time,
          open: bar.open,
          high: bar.high,
          low: bar.low,
          close: bar.close
        };
        currentMonth = month;
      } else {
        // Update current month data
        monthData.high = Math.max(monthData.high, bar.high);
        monthData.low = Math.min(monthData.low, bar.low);
        monthData.close = bar.close; // Last close of the month
      }
    }
    
    // Add final month
    if (monthData) monthly.push(monthData);
    
    return monthly;
  }

  async function fetchBars(symbol, days = 4000) {
    const url = `${API}/eod?symbol=${encodeURIComponent(symbol)}&days=${days}`;
    const r = await fetch(url);
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    const json = await r.json();
    // Tiingo adapter -> Lightweight Charts
    return (json.data || []).map(b => ({
      time: b.time, open: b.open, high: b.high, low: b.low, close: b.close
    }));
  }

  // Helper functions for per-timeframe storage
  function getStorageKey(symbol, timeframe, dataType) {
    return `eod-${dataType}-${symbol}-${timeframe}`;
  }

  function getLevelsForSymbol(symbol, timeframe = currentTimeframe) {
    const key = getStorageKey(symbol, timeframe, 'levels');
    try {
      return JSON.parse(localStorage.getItem(key) || '[]');
    } catch {
      return [];
    }
  }

  function getTrendlinesForSymbol(symbol, timeframe = currentTimeframe) {
    const key = getStorageKey(symbol, timeframe, 'trendlines');
    try {
      return JSON.parse(localStorage.getItem(key) || '[]');
    } catch {
      return [];
    }
  }

  function saveLevelsForSymbol(symbol, timeframe, levelsArray) {
    const key = getStorageKey(symbol, timeframe, 'levels');
    localStorage.setItem(key, JSON.stringify(levelsArray));
  }

  function saveTrendlinesForSymbol(symbol, timeframe, trendlinesArray) {
    const key = getStorageKey(symbol, timeframe, 'trendlines');
    localStorage.setItem(key, JSON.stringify(trendlinesArray));
  }

  async function loadSymbol(sym, timeframe = currentTimeframe) {
    try {
      // Show loading state
      $('#loading-overlay').classList.add('show');
      $('#status-dot').className = 'status-dot status-loading';
      log(`Loading ${sym} (${timeframe})…`);
      
      // Always fetch daily data first (full 11+ year history)
      const bars = await fetchBars(sym, 4000);
      if (!bars.length) { 
        log('No data returned.'); 
        $('#status-dot').className = 'status-dot status-error';
        return; 
      }

      // Store daily bars for resampling
      dailyBars = bars.filter(bar => 
        bar && 
        bar.time != null && 
        Number.isFinite(bar.open) && Number.isFinite(bar.high) && 
        Number.isFinite(bar.low) && Number.isFinite(bar.close) &&
        !isNaN(bar.open) && !isNaN(bar.high) && 
        !isNaN(bar.low) && !isNaN(bar.close)
      );
      
      // Get bars for current timeframe
      let chartBars;
      switch (timeframe) {
        case '1W':
          chartBars = resampleWeekly(dailyBars);
          break;
        case '1M':
          chartBars = resampleMonthly(dailyBars);
          break;
        case '1D':
        default:
          chartBars = dailyBars;
          break;
      }
      
      console.log(`[EOD] Filtered ${bars.length - dailyBars.length} invalid bars`);
      candleSeries.setData(chartBars);
      
      // Update indicators based on toggles with validation
      if (indicators.ema200) {
        const ema200 = ema(chartBars, 200);
        // Validate EMA data before setting
        const validEMA = ema200.filter(point => 
          point && point.time != null && Number.isFinite(point.value) && !isNaN(point.value)
        );
        emaSeries.setData(validEMA);
      } else {
        emaSeries.setData([]);
      }
      
      if (indicators.bb20) {
        const bb = bollingerBands(chartBars, 20, 2);
        // Validate Bollinger Bands data before setting
        const validUpper = bb.upper.filter(point => 
          point && point.time != null && Number.isFinite(point.value) && !isNaN(point.value)
        );
        const validMiddle = bb.middle.filter(point => 
          point && point.time != null && Number.isFinite(point.value) && !isNaN(point.value)
        );
        const validLower = bb.lower.filter(point => 
          point && point.time != null && Number.isFinite(point.value) && !isNaN(point.value)
        );
        bbUpperSeries.setData(validUpper);
        bbMiddleSeries.setData(validMiddle);
        bbLowerSeries.setData(validLower);
      } else {
        bbUpperSeries.setData([]);
        bbMiddleSeries.setData([]);
        bbLowerSeries.setData([]);
      }
      
      chart.timeScale().fitContent();
      currentSymbol = sym;
      currentTimeframe = timeframe;
      localStorage.setItem('eod-current-symbol', sym);
      localStorage.setItem('eod-current-timeframe', timeframe);
      updateTimeframeDisplay();
      updateWatchlistDisplay();
      updateMiniChartActiveState(); // Update active mini-chart highlighting
      updateLevelsDisplay();
      drawLevelsOnChart();
      updateTrendlinesDisplay();
      drawTrendlinesOnChart();
      
      // Update status to connected
      $('#status-dot').className = 'status-dot status-connected';
      log(`Loaded ${sym}: ${bars.length} bars`);
      
      // Store tfBars for signal evaluation
      tfBars = chartBars;
      
      // Evaluate signals for the loaded data
      evaluateCurrentSignals();
      
    } catch (e) {
      log('Load failed: ' + e.message);
      $('#status-dot').className = 'status-dot status-error';
    } finally {
      // Hide loading state
      $('#loading-overlay').classList.remove('show');
    }
  }

  // ---- Watchlist Management
  function saveWatchlist() {
    localStorage.setItem('eod-watchlist', JSON.stringify(watchlist));
  }

  function addSymbol() {
    const symbol = $('#new-symbol').value.trim().toUpperCase();
    // Validate symbol format (alphanumeric, dots, dashes only)
    if (symbol && /^[A-Z0-9\.\-]{1,10}$/.test(symbol) && !watchlist.includes(symbol)) {
      watchlist.push(symbol);
      saveWatchlist();
      updateWatchlistDisplay();
      $('#new-symbol').value = '';
    } else if (symbol && !watchlist.includes(symbol)) {
      log('Invalid symbol format. Use letters, numbers, dots, and dashes only.');
    }
  }

  function removeSymbol(symbol) {
    watchlist = watchlist.filter(s => s !== symbol);
    saveWatchlist();
    updateWatchlistDisplay();
    if (currentSymbol === symbol && watchlist.length > 0) {
      loadSymbol(watchlist[0]);
    }
  }

  function updateWatchlistDisplay() {
    const container = $('#watchlist');
    container.innerHTML = ''; // Clear existing content
    
    watchlist.forEach(symbol => {
      const item = document.createElement('div');
      item.className = `symbol-item ${symbol === currentSymbol ? 'active' : ''}`;
      item.dataset.symbol = symbol;
      
      const nameSpan = document.createElement('span');
      nameSpan.className = 'symbol-name';
      nameSpan.textContent = symbol; // Safe text content
      
      const removeBtn = document.createElement('button');
      removeBtn.className = 'remove-btn';
      removeBtn.textContent = '×';
      removeBtn.dataset.symbol = symbol;
      removeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        removeSymbol(e.target.dataset.symbol);
      });
      
      item.appendChild(nameSpan);
      item.appendChild(removeBtn);
      container.appendChild(item);
    });
    
    // Update the watchlist board when watchlist changes
    updateWatchlistBoard();
  }

  // Watchlist Board - Mini Chart Dashboard
  let miniCharts = {}; // Store mini-chart instances

  function updateWatchlistBoard() {
    const container = $('#watchlist-board');
    
    // Dispose of existing mini-charts to prevent memory leaks
    disposeMiniCharts();
    
    // Clear container
    container.innerHTML = '';
    
    // Create mini-chart for each symbol in watchlist
    watchlist.forEach(symbol => {
      createMiniChart(symbol, container);
    });
    
    // Load data for all mini-charts
    watchlist.forEach(symbol => {
      loadMiniChartData(symbol);
    });
  }

  function createMiniChart(symbol, container) {
    const miniContainer = document.createElement('div');
    miniContainer.className = `mini-chart-container ${symbol === currentSymbol ? 'active' : ''}`;
    miniContainer.dataset.symbol = symbol;
    
    // Header with symbol, price, and change
    const header = document.createElement('div');
    header.className = 'mini-chart-header';
    header.innerHTML = `
      <div class="mini-chart-symbol">${symbol}</div>
      <div class="mini-chart-price" id="price-${symbol}">--</div>
      <div class="mini-chart-change" id="change-${symbol}">--</div>
    `;
    
    // Chart container
    const chartDiv = document.createElement('div');
    chartDiv.className = 'mini-chart';
    chartDiv.id = `mini-chart-${symbol}`;
    
    // Loading indicator
    const loadingDiv = document.createElement('div');
    loadingDiv.className = 'mini-chart-loading';
    loadingDiv.textContent = 'Loading...';
    
    miniContainer.appendChild(header);
    miniContainer.appendChild(chartDiv);
    miniContainer.appendChild(loadingDiv);
    
    // Click event to switch to this symbol for full analysis
    miniContainer.addEventListener('click', () => {
      loadSymbol(symbol, currentTimeframe);
    });
    
    container.appendChild(miniContainer);
    
    // Create lightweight chart instance
    try {
      const miniChart = LightweightCharts.createChart(chartDiv, {
        width: chartDiv.offsetWidth,
        height: 80,
        layout: {
          background: { color: 'transparent' },
          textColor: '#d1d5db',
        },
        grid: {
          vertLines: { visible: false },
          horzLines: { visible: false },
        },
        crosshair: { mode: 0 }, // Hidden
        rightPriceScale: { visible: false },
        leftPriceScale: { visible: false },
        timeScale: { visible: false },
        handleScroll: false,
        handleScale: false,
      });
      
      const candleSeries = miniChart.addCandlestickSeries({
        upColor: '#10b981',
        downColor: '#ef4444',
        borderUpColor: '#10b981',
        borderDownColor: '#ef4444',
        wickUpColor: '#10b981',
        wickDownColor: '#ef4444',
      });
      
      miniCharts[symbol] = { 
        chart: miniChart, 
        candleSeries, 
        container: miniContainer,
        loadingDiv,
        priceEl: header.querySelector('.mini-chart-price'),
        changeEl: header.querySelector('.mini-chart-change')
      };
      
      // Hide loading indicator once chart is created
      loadingDiv.style.display = 'none';
      
    } catch (error) {
      console.error(`Error creating mini-chart for ${symbol}:`, error);
      loadingDiv.textContent = 'Error';
    }
  }

  async function loadMiniChartData(symbol) {
    try {
      const miniChartData = miniCharts[symbol];
      if (!miniChartData) return;
      
      const { loadingDiv, priceEl, changeEl, candleSeries } = miniChartData;
      
      loadingDiv.style.display = 'flex';
      loadingDiv.textContent = 'Loading...';
      
      // Fetch limited data for mini-chart (last 60 bars for better performance)
      const response = await fetch(`/api/data?symbol=${symbol}&timeframe=1D`);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      
      const rawData = await response.json();
      if (!rawData || !Array.isArray(rawData) || rawData.length === 0) {
        throw new Error('No data received');
      }
      
      // Get recent data (last 60 bars for mini-chart - enough for context)
      const recentData = rawData.slice(-60);
      
      // Process data for chart
      const chartData = recentData.map(bar => ({
        time: bar.date,
        open: parseFloat(bar.open),
        high: parseFloat(bar.high),
        low: parseFloat(bar.low),
        close: parseFloat(bar.close)
      }));
      
      // Validate data
      const validData = chartData.filter(bar => 
        bar.open !== null && bar.high !== null && bar.low !== null && bar.close !== null &&
        !isNaN(bar.open) && !isNaN(bar.high) && !isNaN(bar.low) && !isNaN(bar.close)
      );
      
      if (validData.length === 0) {
        throw new Error('No valid data after filtering');
      }
      
      // Update mini-chart
      candleSeries.setData(validData);
      
      // Update price and change info using stored element references
      const latestBar = validData[validData.length - 1];
      const previousBar = validData[validData.length - 2];
      
      if (latestBar && previousBar) {
        const price = latestBar.close.toFixed(2);
        const change = latestBar.close - previousBar.close;
        const changePercent = ((change / previousBar.close) * 100).toFixed(2);
        
        priceEl.textContent = `$${price}`;
        
        const changeText = `${change >= 0 ? '+' : ''}${change.toFixed(2)} (${changePercent}%)`;
        changeEl.textContent = changeText;
        changeEl.className = `mini-chart-change ${change >= 0 ? 'positive' : 'negative'}`;
      }
      
      // Hide loading indicator
      loadingDiv.style.display = 'none';
      
    } catch (error) {
      console.error(`Error loading data for ${symbol}:`, error);
      const miniChartData = miniCharts[symbol];
      if (miniChartData && miniChartData.loadingDiv) {
        miniChartData.loadingDiv.textContent = 'Error';
        miniChartData.loadingDiv.style.display = 'flex';
      }
    }
  }

  function disposeMiniCharts() {
    Object.keys(miniCharts).forEach(symbol => {
      if (miniCharts[symbol] && miniCharts[symbol].chart) {
        miniCharts[symbol].chart.remove();
      }
    });
    miniCharts = {};
  }

  function updateMiniChartActiveState() {
    // Update active state for mini-charts when current symbol changes
    Object.keys(miniCharts).forEach(symbol => {
      const container = miniCharts[symbol].container;
      if (container) {
        if (symbol === currentSymbol) {
          container.classList.add('active');
        } else {
          container.classList.remove('active');
        }
      }
    });
  }

  function updateIndicatorToggles() {
    $('#ema-toggle').className = indicators.ema200 ? 'toggle-switch active' : 'toggle-switch';
    $('#bb-toggle').className = indicators.bb20 ? 'toggle-switch active' : 'toggle-switch';
  }

  function updateTimeframeDisplay() {
    // Update timeframe button states
    $$('.tf.btn-toggle').forEach(btn => {
      btn.classList.remove('active');
      if (btn.dataset.tf === currentTimeframe) {
        btn.classList.add('active');
      }
    });
  }

  function saveIndicators() {
    localStorage.setItem('eod-indicators', JSON.stringify(indicators));
  }

  function saveLevels() {
    const symbolLevels = getLevelsForSymbol(currentSymbol, currentTimeframe);
    saveLevelsForSymbol(currentSymbol, currentTimeframe, symbolLevels);
    evaluateCurrentSignals(); // Update signals when levels change
  }

  function saveTrendlines() {
    const symbolTrendlines = getTrendlinesForSymbol(currentSymbol, currentTimeframe);
    saveTrendlinesForSymbol(currentSymbol, currentTimeframe, symbolTrendlines);
    evaluateCurrentSignals(); // Update signals when trendlines change
  }

  function addTrendline(startTime, startPrice, endTime, endPrice) {
    const symbolTrendlines = getTrendlinesForSymbol(currentSymbol, currentTimeframe);
    const trendlineId = Date.now().toString();
    const trendline = {
      id: trendlineId,
      startTime: startTime,
      startPrice: startPrice,
      endTime: endTime,
      endPrice: endPrice,
      symbol: currentSymbol,
      color: '#f59e0b', // default color
      selected: false
    };
    symbolTrendlines.push(trendline);
    saveTrendlinesForSymbol(currentSymbol, currentTimeframe, symbolTrendlines);
    updateTrendlinesDisplay();
    drawTrendlinesOnChart();
    evaluateCurrentSignals(); // Update signals when trendline added
    return trendline;
  }

  function removeTrendline(trendlineId) {
    const symbolTrendlines = getTrendlinesForSymbol(currentSymbol, currentTimeframe);
    const filtered = symbolTrendlines.filter(t => t.id !== trendlineId);
    saveTrendlinesForSymbol(currentSymbol, currentTimeframe, filtered);
    
    // Clear selection if deleted trendline was selected
    if (selectedLine && selectedLine.type === 'trendline' && selectedLine.data.id === trendlineId) {
      selectedLine = null;
    }
    
    updateTrendlinesDisplay();
    drawTrendlinesOnChart();
    evaluateCurrentSignals(); // Update signals when trendline removed
  }

  function clearAllTrendlines() {
    saveTrendlinesForSymbol(currentSymbol, currentTimeframe, []);
    updateTrendlinesDisplay();
    drawTrendlinesOnChart();
    evaluateCurrentSignals(); // Update signals when all trendlines cleared
  }

  function addLevel(price) {
    const symbolLevels = getLevelsForSymbol(currentSymbol, currentTimeframe);
    const levelId = Date.now().toString();
    const level = {
      id: levelId,
      price: price,
      symbol: currentSymbol,
      color: '#60a5fa', // default color
      selected: false
    };
    symbolLevels.push(level);
    saveLevelsForSymbol(currentSymbol, currentTimeframe, symbolLevels);
    updateLevelsDisplay();
    drawLevelsOnChart();
    evaluateCurrentSignals(); // Update signals when level added
    return level;
  }

  function selectLevel(levelId) {
    const symbolLevels = getLevelsForSymbol(currentSymbol, currentTimeframe);
    
    // Clear all selections first
    symbolLevels.forEach(l => l.selected = false);
    
    // Select the clicked level
    const level = symbolLevels.find(l => l.id === levelId);
    if (level) {
      level.selected = true;
      selectedLine = { type: 'level', data: level };
      log(`📏 Selected level at ${level.price.toFixed(2)}`);
    }
    
    saveLevelsForSymbol(currentSymbol, currentTimeframe, symbolLevels);
    updateLevelsDisplay();
    drawLevelsOnChart();
  }

  function selectTrendline(trendlineId) {
    const symbolTrendlines = getTrendlinesForSymbol(currentSymbol, currentTimeframe);
    
    // Clear all selections first
    symbolTrendlines.forEach(t => t.selected = false);
    
    // Select the clicked trendline
    const trendline = symbolTrendlines.find(t => t.id === trendlineId);
    if (trendline) {
      trendline.selected = true;
      selectedLine = { type: 'trendline', data: trendline };
      log(`📐 Selected trendline from ${new Date(trendline.startTime * 1000).toISOString().slice(0, 10)}`);
    }
    
    saveTrendlinesForSymbol(currentSymbol, currentTimeframe, symbolTrendlines);
    updateTrendlinesDisplay();
    drawTrendlinesOnChart();
  }

  function removeLevel(levelId) {
    const symbolLevels = getLevelsForSymbol(currentSymbol, currentTimeframe);
    const filtered = symbolLevels.filter(l => l.id !== levelId);
    saveLevelsForSymbol(currentSymbol, currentTimeframe, filtered);
    
    // Clear selection if deleted level was selected
    if (selectedLine && selectedLine.type === 'level' && selectedLine.data.id === levelId) {
      selectedLine = null;
    }
    
    updateLevelsDisplay();
    drawLevelsOnChart();
  }

  function clearAllLevels() {
    saveLevelsForSymbol(currentSymbol, currentTimeframe, []);
    updateLevelsDisplay();
    drawLevelsOnChart();
    evaluateCurrentSignals(); // Update signals when all levels cleared
  }

  function updateLevelsDisplay() {
    const container = $('#levels');
    if (!container) return;
    container.innerHTML = '';
    
    const symbolLevels = getLevelsForSymbol(currentSymbol, currentTimeframe);
    symbolLevels.forEach(level => {
      const row = document.createElement('div');
      row.className = `row level-item ${level.selected ? 'selected' : ''}`;
      row.style.cursor = 'pointer';
      
      // Main content - clickable for selection
      const content = document.createElement('span');
      content.className = 'level-content';
      content.innerHTML = `
        <span class="level-price">${level.price.toFixed(2)}</span>
        <span class="level-color" style="background-color: ${level.color || '#60a5fa'}"></span>
      `;
      
      // Click to select level
      content.addEventListener('click', (e) => {
        e.stopPropagation();
        selectLevel(level.id);
      });
      
      // Delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'kill';
      deleteBtn.textContent = '✕';
      deleteBtn.title = 'Delete level';
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        removeLevel(level.id);
      });
      
      row.appendChild(content);
      row.appendChild(deleteBtn);
      container.appendChild(row);
    });
  }

  function updateTrendlinesDisplay() {
    const container = $('#trends');
    if (!container) return;
    container.innerHTML = '';
    
    const symbolTrendlines = getTrendlinesForSymbol(currentSymbol, currentTimeframe);
    symbolTrendlines.forEach(trendline => {
      const row = document.createElement('div');
      row.className = `row trendline-item ${trendline.selected ? 'selected' : ''}`;
      row.style.cursor = 'pointer';
      
      // Main content - clickable for selection
      const content = document.createElement('span');
      content.className = 'trendline-content';
      
      const startDate = new Date(trendline.startTime * 1000).toISOString().slice(0, 10);
      const endDate = new Date(trendline.endTime * 1000).toISOString().slice(0, 10);
      const priceRange = `${trendline.startPrice.toFixed(2)} → ${trendline.endPrice.toFixed(2)}`;
      
      content.innerHTML = `
        <div class="trendline-dates">${startDate} → ${endDate}</div>
        <div class="trendline-prices">${priceRange}</div>
        <span class="trendline-color" style="background-color: ${trendline.color || '#22d3ee'}"></span>
      `;
      
      // Click to select trendline
      content.addEventListener('click', (e) => {
        e.stopPropagation();
        selectTrendline(trendline.id);
      });
      
      // Delete button
      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'kill';
      deleteBtn.textContent = '✕';
      deleteBtn.title = 'Delete trendline';
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        removeTrendline(trendline.id);
      });
      
      row.appendChild(content);
      row.appendChild(deleteBtn);
      container.appendChild(row);
    });
  }

  // Check if a point is within the visible TIME range (simplified approach)
  function isTimeInVisibleRange(time) {
    try {
      const timeRange = chart.timeScale().getVisibleRange();
      if (!timeRange) return true; // If can't determine range, allow drawing
      
      return time >= timeRange.from && time <= timeRange.to;
    } catch (error) {
      console.warn('[EOD] Error checking visible time range:', error);
      return true; // If error, allow drawing to prevent functional regression
    }
  }

  // Line extent capping - limits trendline projection based on timeframe
  function getMaxProjectionTime(startTime, timeframe) {
    const start = new Date(startTime * 1000);
    let maxProjection;
    
    switch (timeframe.toLowerCase()) {
      case '1d':
        // Daily charts: 1 year projection
        maxProjection = new Date(start);
        maxProjection.setFullYear(start.getFullYear() + 1);
        break;
      case '1w':
        // Weekly charts: 2 years projection  
        maxProjection = new Date(start);
        maxProjection.setFullYear(start.getFullYear() + 2);
        break;
      case '1m':
        // Monthly charts: 5 years projection
        maxProjection = new Date(start);
        maxProjection.setFullYear(start.getFullYear() + 5);
        break;
      case '4h':
        // Intraday charts: 6 months projection
        maxProjection = new Date(start);
        maxProjection.setMonth(start.getMonth() + 6);
        break;
      default:
        // Default: 1 year
        maxProjection = new Date(start);
        maxProjection.setFullYear(start.getFullYear() + 1);
        break;
    }
    
    return Math.floor(maxProjection.getTime() / 1000);
  }

  function capTrendlineExtent(trendline) {
    const maxEndTime = getMaxProjectionTime(trendline.startTime, currentTimeframe);
    
    if (trendline.endTime > maxEndTime) {
      // Calculate the slope to project to the max allowed time
      const timeDelta = trendline.endTime - trendline.startTime;
      const priceDelta = trendline.endPrice - trendline.startPrice;
      const slope = priceDelta / timeDelta;
      
      const cappedTimeDelta = maxEndTime - trendline.startTime;
      const cappedPriceDelta = slope * cappedTimeDelta;
      
      return {
        ...trendline,
        endTime: maxEndTime,
        endPrice: trendline.startPrice + cappedPriceDelta,
        isCapped: true
      };
    }
    
    return { ...trendline, isCapped: false };
  }

  function drawTrendlinesOnChart() {
    const symbolTrendlines = (getTrendlinesForSymbol(currentSymbol, currentTimeframe) || [])
      .filter(t =>
        t && t.id != null &&
        Number.isFinite(t.startTime) && Number.isFinite(t.endTime) &&
        Number.isFinite(t.startPrice) && Number.isFinite(t.endPrice)
      );

    // --- remove ones that no longer exist ---
    for (const [id, rec] of trendSeriesById.entries()) {
      if (!symbolTrendlines.find(t => t.id === id)) {
        chart.removeSeries(rec.series);
        trendSeriesById.delete(id);
      }
    }

    // --- upsert the rest (no full clear) ---
    for (const t of symbolTrendlines) {
      // Apply line extent capping to prevent infinite projection
      const cappedTrendline = capTrendlineExtent(t);
      
      const inRange =
        isTimeInVisibleRange(cappedTrendline.startTime) || isTimeInVisibleRange(cappedTrendline.endTime);
      if (!inRange) continue; // don't expand chart

      const lineData = [
        { time: cappedTrendline.startTime, value: cappedTrendline.startPrice },
        { time: cappedTrendline.endTime,   value: cappedTrendline.endPrice   },
      ];
      if (!lineData.every(p => Number.isFinite(p.time) && Number.isFinite(p.value))) continue;

      let rec = trendSeriesById.get(t.id);
      if (!rec) {
        // Visual styling with capping indicator
        const lineColor = t.selected ? '#22d3ee' : (cappedTrendline.isCapped ? '#fbbf24' : (t.color || '#f59e0b'));
        const lineStyle = cappedTrendline.isCapped ? 1 : 0; // Dashed if capped
        
        const series = chart.addLineSeries({
          color: lineColor,
          lineWidth: t.selected ? 5 : 2,
          lineStyle: lineStyle,
        });
        // stop autoscale influence
        series.applyOptions({ autoscaleInfoProvider: () => null });
        rec = { series, data: cappedTrendline };
        trendSeriesById.set(t.id, rec);
      } else {
        // only restyle if selection/color changed
        const lineColor = t.selected ? '#22d3ee' : (cappedTrendline.isCapped ? '#fbbf24' : (t.color || '#f59e0b'));
        const lineStyle = cappedTrendline.isCapped ? 1 : 0; // Dashed if capped
        
        rec.series.applyOptions({
          color: lineColor,
          lineWidth: t.selected ? 5 : 2,
          lineStyle: lineStyle,
        });
        rec.data = cappedTrendline;
      }

      rec.series.setData(lineData);
    }

    // mirror into your external array if other code reads it
    currentTrendlines = [...trendSeriesById.values()].map(r => r.series);
  }

  function drawLevelsOnChart() {
    const symbolLevels = (getLevelsForSymbol(currentSymbol, currentTimeframe) || [])
      .filter(L => L && L.id != null && Number.isFinite(L.price) && L.price > 0);

    // remove deleted
    for (const [id, rec] of levelLineById.entries()) {
      if (!symbolLevels.find(L => L.id === id)) {
        try { candleSeries.removePriceLine(rec.line); } catch {}
        levelLineById.delete(id);
      }
    }

    // upsert
    for (const L of symbolLevels) {
      const existing = levelLineById.get(L.id);
      const opts = {
        price: L.price,
        color: L.selected ? '#22d3ee' : (L.color || '#60a5fa'),
        lineWidth: L.selected ? 5 : 2,
        lineStyle: 0,
        axisLabelVisible: true,
        title: `Level ${(+L.price).toFixed(2)}`
      };

      if (!existing) {
        const line = candleSeries.createPriceLine(opts);
        levelLineById.set(L.id, { line, data: L });
      } else {
        // recreate only if price OR style changed
        const changed = existing.data.price !== L.price ||
                        existing.data.selected !== L.selected ||
                        existing.data.color !== L.color;
        if (changed) {
          try { candleSeries.removePriceLine(existing.line); } catch {}
          const line = candleSeries.createPriceLine(opts);
          levelLineById.set(L.id, { line, data: L });
        } else {
          existing.data = L;
        }
      }
    }

    currentLevels = [...levelLineById.values()].map(r => r.line);
  }

  // ---- Chart Interaction
  
  function setupChartInteraction() {
    chart.subscribeClick(param => {
      if (param.point) {
        const price = candleSeries.coordinateToPrice(param.point.y);
        const time = chart.timeScale().coordinateToTime(param.point.x);
        
        if (price !== null && !isNaN(price) && time !== null && time !== undefined) {
          // Check if clicking on existing line for alert setup (when not in drawing mode)
          if (!drawingMode) {
            const clickedLine = findLineNearClick(param.point.x, param.point.y);
            if (clickedLine) {
              // Show alert modal instead of just selecting
              openAlertModal({
                type: clickedLine.type,
                id: clickedLine.data.id,
                price: clickedLine.data.price,
                trendlineData: clickedLine.data
              });
              log(`Alert setup for ${clickedLine.type} line`);
              return;
            } else {
              // Check if clicking on indicators (EMA or Bollinger Bands)
              const indicatorClick = detectIndicatorClick(param.point.x, param.point.y);
              if (indicatorClick) {
                openAlertModal(indicatorClick);
                log(`Alert setup for ${indicatorClick.type}`);
                return;
              }
              
              // Clicked on empty space - deselect current line
              if (selectedLine) {
                deselectLine();
                log('Line deselected');
                return;
              }
            }
          }
          
          // Handle drawing modes
          if (drawingMode && drawingTool === 'level') {
            addLevel(price);
            log(`Level added at ${price.toFixed(2)}`);
            // Auto-disable drawing mode after completing level
            drawingMode = false;
            $('#level-tool').classList.remove('active');
            document.body.classList.remove('drawing-mode');
          } else if (drawingMode && drawingTool === 'trendline') {
            if (!trendlineStart) {
              // First click: set start point
              trendlineStart = { time, price };
              enableTrendlinePreview();
              log('Trendline started. Click second point to finish.');
            } else {
              // Second click: complete trendline
              disableTrendlinePreview();
              addTrendline(trendlineStart.time, trendlineStart.price, time, price);
              log(`Trendline added from ${trendlineStart.price.toFixed(2)} to ${price.toFixed(2)}`);
              // Auto-disable drawing mode after completing trendline
              drawingMode = false;
              $('#trendline-tool').classList.remove('active');
              document.body.classList.remove('drawing-mode');
              trendlineStart = null;
            }
          }
        }
      }
    });

    // ==== SETUP BUTTERY SMOOTH POINTER EVENTS ====
    let chartContainer = document.getElementById('chart');
    chartContainer.addEventListener('pointerdown', onPointerDown);
    chartContainer.addEventListener('pointermove', onPointerMove, { passive: true });
    chartContainer.addEventListener('pointerup', onPointerUp);
    chartContainer.addEventListener('pointercancel', onPointerUp);

    // Keep mousemove only for trendline preview (non-performance critical)
    chartContainer.addEventListener('mousemove', (event) => {
      if (drawingMode && drawingTool === 'trendline' && trendlineStart && previewTrendline) {
        // Throttle preview updates for better performance (max 60fps)
        if (previewUpdateThrottle) {
          clearTimeout(previewUpdateThrottle);
        }
        previewUpdateThrottle = setTimeout(() => {
          const rect = chartContainer.getBoundingClientRect();
          const point = { x: event.clientX - rect.left, y: event.clientY - rect.top };
          const price = candleSeries.coordinateToPrice(point.y);
          const time = chart.timeScale().coordinateToTime(point.x);
          
          if (price !== null && !isNaN(price) && time !== null && time !== undefined) {
            updateTrendlinePreview(time, price);
          }
        }, 16); // ~60fps throttling
      }
      
      // OLD DRAG HANDLERS REMOVED - Now handled by optimized pointer events
    });
    
    // OLD MOUSEDOWN HANDLER REMOVED - Now handled by optimized pointer events
    // OLD MOUSEUP HANDLER REMOVED - Now handled by optimized pointer events
  }

  // Check if click is near a trendline endpoint for resizing
  function checkEndpointHit(clickX, clickY, trendlineData, tolerance = 12) {
    if (!trendlineData || !trendlineData.startTime || !trendlineData.endTime) return null;
    
    try {
      // Get coordinates of start and end points with null safety
      const startX = chart.timeScale().timeToCoordinate(trendlineData.startTime);
      const startY = candleSeries.priceToCoordinate(trendlineData.startPrice);
      const endX = chart.timeScale().timeToCoordinate(trendlineData.endTime);
      const endY = candleSeries.priceToCoordinate(trendlineData.endPrice);
      
      // Strict null checking - if ANY coordinate is null, abort
      if (startX === null || startY === null || endX === null || endY === null ||
          !Number.isFinite(startX) || !Number.isFinite(startY) || 
          !Number.isFinite(endX) || !Number.isFinite(endY)) {
        return null;
      }
      
      // Check distance to start point
      const startDistance = Math.sqrt(Math.pow(clickX - startX, 2) + Math.pow(clickY - startY, 2));
      if (startDistance <= tolerance) {
        return 'start';
      }
      
      // Check distance to end point
      const endDistance = Math.sqrt(Math.pow(clickX - endX, 2) + Math.pow(clickY - endY, 2));
      if (endDistance <= tolerance) {
        return 'end';
      }
    } catch (error) {
      console.warn('[EOD] Coordinate conversion error in checkEndpointHit:', error);
      return null;
    }
    
    return null;
  }

  // Detect clicks on indicators (EMA, Bollinger Bands)
  function detectIndicatorClick(clickX, clickY, tolerance = 8) {
    if (!tfBars || tfBars.length === 0) return null;
    
    const clickTime = chart.timeScale().coordinateToTime(clickX);
    const clickPrice = candleSeries.coordinateToPrice(clickY);
    if (!clickTime || !clickPrice) return null;
    
    // Find the closest bar to the click
    const closestBarIndex = findClosestBarIndex(tfBars, clickTime);
    if (closestBarIndex === -1) return null;
    
    // Check if indicators are enabled and have data
    if (indicators.ema200) {
      const emaData = emaFromBars(tfBars, 200);
      if (emaData && emaData[closestBarIndex]) {
        const emaValue = emaData[closestBarIndex].value;
        const emaY = candleSeries.priceToCoordinate(emaValue);
        if (emaY !== null && Math.abs(clickY - emaY) <= tolerance) {
          return {
            type: 'ema',
            id: 'ema200',
            price: emaValue,
            currentValue: emaValue
          };
        }
      }
    }
    
    if (indicators.bb20) {
      const bbData = bbFromBars(tfBars, 20, 2);
      if (bbData && bbData.upper[closestBarIndex]) {
        const upperValue = bbData.upper[closestBarIndex].value;
        const lowerValue = bbData.lower[closestBarIndex].value;
        
        const upperY = candleSeries.priceToCoordinate(upperValue);
        const lowerY = candleSeries.priceToCoordinate(lowerValue);
        
        if (upperY !== null && Math.abs(clickY - upperY) <= tolerance) {
          return {
            type: 'bb_upper',
            id: 'bb_upper',
            price: upperValue,
            currentValue: upperValue
          };
        }
        
        if (lowerY !== null && Math.abs(clickY - lowerY) <= tolerance) {
          return {
            type: 'bb_lower',
            id: 'bb_lower',
            price: lowerValue,
            currentValue: lowerValue
          };
        }
      }
    }
    
    return null;
  }
  
  // Helper function to find closest bar index for a given time
  function findClosestBarIndex(bars, targetTime) {
    if (!bars || bars.length === 0) return -1;
    
    let closest = 0;
    let minDiff = Math.abs(bars[0].time - targetTime);
    
    for (let i = 1; i < bars.length; i++) {
      const diff = Math.abs(bars[i].time - targetTime);
      if (diff < minDiff) {
        minDiff = diff;
        closest = i;
      }
    }
    
    return closest;
  }

  // Line detection for selection with multi-line conflict resolution
  function findLineNearClick(clickX, clickY, tolerance = 8) {
    const candidates = [];
    
    // PRIORITY 1: Check if currently selected line is still being hit (sticky selection)
    if (selectedLine) {
      if (selectedLine.type === 'level') {
        for (let level of currentLevels) {
          if (level._levelData && level._levelData.id === selectedLine.data.id) {
            const levelY = candleSeries.priceToCoordinate(level._levelData.price);
            if (levelY !== null && Math.abs(clickY - levelY) <= tolerance) {
              return { type: 'level', data: level._levelData, series: level, distance: Math.abs(clickY - levelY) };
            }
          }
        }
      } else if (selectedLine.type === 'trendline') {
        for (let trendline of currentTrendlines) {
          if (trendline._trendlineData && trendline._trendlineData.id === selectedLine.data.id) {
            const data = trendline._trendlineData;
            try {
              const startX = chart.timeScale().timeToCoordinate(data.startTime);
              const startY = candleSeries.priceToCoordinate(data.startPrice);
              const endX = chart.timeScale().timeToCoordinate(data.endTime);
              const endY = candleSeries.priceToCoordinate(data.endPrice);
              
              if (startX !== null && startY !== null && endX !== null && endY !== null &&
                  Number.isFinite(startX) && Number.isFinite(startY) && 
                  Number.isFinite(endX) && Number.isFinite(endY)) {
                const distance = pointToLineDistance(clickX, clickY, startX, startY, endX, endY);
                if (distance <= tolerance) {
                  return { type: 'trendline', data: data, series: trendline, distance: distance };
                }
              }
            } catch (error) {
              console.warn('[EOD] Coordinate conversion error for selected line:', error);
            }
          }
        }
      }
    }
    
    // PRIORITY 2: Check all levels and collect candidates
    for (let level of currentLevels) {
      if (level._levelData) {
        try {
          const levelY = candleSeries.priceToCoordinate(level._levelData.price);
          if (levelY !== null && Number.isFinite(levelY)) {
            const distance = Math.abs(clickY - levelY);
            if (distance <= tolerance) {
              candidates.push({ 
                type: 'level', 
                data: level._levelData, 
                series: level, 
                distance: distance 
              });
            }
          }
        } catch (error) {
          console.warn('[EOD] Coordinate conversion error for level:', error);
        }
      }
    }
    
    // PRIORITY 3: Check all trendlines and collect candidates
    for (let trendline of currentTrendlines) {
      if (trendline._trendlineData) {
        const data = trendline._trendlineData;
        try {
          const startX = chart.timeScale().timeToCoordinate(data.startTime);
          const startY = candleSeries.priceToCoordinate(data.startPrice);
          const endX = chart.timeScale().timeToCoordinate(data.endTime);
          const endY = candleSeries.priceToCoordinate(data.endPrice);
          
          if (startX !== null && startY !== null && endX !== null && endY !== null &&
              Number.isFinite(startX) && Number.isFinite(startY) && 
              Number.isFinite(endX) && Number.isFinite(endY)) {
            const distance = pointToLineDistance(clickX, clickY, startX, startY, endX, endY);
            if (distance <= tolerance) {
              candidates.push({ 
                type: 'trendline', 
                data: data, 
                series: trendline, 
                distance: distance 
              });
            }
          }
        } catch (error) {
          console.warn('[EOD] Coordinate conversion error for trendline:', error);
        }
      }
    }
    
    // PRIORITY 4: Select best candidate by shortest distance
    if (candidates.length === 0) return null;
    if (candidates.length === 1) return candidates[0];
    
    // Multiple candidates - pick the closest one
    const closest = candidates.reduce((best, current) => 
      current.distance < best.distance ? current : best
    );
    
    log(`🎯 Selected closest line from ${candidates.length} candidates (distance: ${closest.distance.toFixed(1)}px)`);
    return closest;
  }

  // Calculate distance from a point to a line segment
  function pointToLineDistance(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;
    
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    
    if (lenSq === 0) return Math.sqrt(A * A + B * B); // Point distance
    
    let param = dot / lenSq;
    param = Math.max(0, Math.min(1, param)); // Clamp to segment
    
    const xx = x1 + param * C;
    const yy = y1 + param * D;
    
    const dx = px - xx;
    const dy = py - yy;
    return Math.sqrt(dx * dx + dy * dy);
  }

  function selectLine(line) {
    // First deselect any current selection
    if (selectedLine) {
      deselectLine();
    }
    
    selectedLine = line;
    isLineSelected = true;
    
    // Mark the line as selected in storage
    if (line.type === 'level') {
      const levels = getLevelsForSymbol(currentSymbol);
      const levelIndex = levels.findIndex(l => l.id === line.data.id);
      if (levelIndex >= 0) {
        levels[levelIndex].selected = true;
        saveLevels();
      }
    } else if (line.type === 'trendline') {
      const trendlines = getTrendlinesForSymbol(currentSymbol);
      const trendlineIndex = trendlines.findIndex(t => t.id === line.data.id);
      if (trendlineIndex >= 0) {
        trendlines[trendlineIndex].selected = true;
        saveTrendlines();
      }
    }
    
    // Redraw lines to show selection visually
    if (line.type === 'level') {
      drawLevelsOnChart();
    } else {
      drawTrendlinesOnChart();
    }
    
    // Show line controls
    const lineControlsDiv = document.getElementById('line-controls');
    lineControlsDiv.style.display = 'block';
    
    // Update color picker to show current color
    document.querySelectorAll('.color-option').forEach(opt => {
      opt.classList.remove('active');
      if (opt.dataset.color === line.data.color) {
        opt.classList.add('active');
      }
    });
    
    // Add resize handles for selected line
    addLineHandles();
  }

  function deselectLine() {
    if (!selectedLine) return;
    
    // Mark the line as not selected in storage
    if (selectedLine.type === 'level') {
      const levels = getLevelsForSymbol(currentSymbol);
      const levelIndex = levels.findIndex(l => l.id === selectedLine.data.id);
      if (levelIndex >= 0) {
        levels[levelIndex].selected = false;
        saveLevels();
      }
    } else if (selectedLine.type === 'trendline') {
      const trendlines = getTrendlinesForSymbol(currentSymbol);
      const trendlineIndex = trendlines.findIndex(t => t.id === selectedLine.data.id);
      if (trendlineIndex >= 0) {
        trendlines[trendlineIndex].selected = false;
        saveTrendlines();
      }
    }
    
    // Redraw lines to remove selection visuals
    if (selectedLine.type === 'level') {
      drawLevelsOnChart();
    } else {
      drawTrendlinesOnChart();
    }
    
    selectedLine = null;
    isLineSelected = false;
    
    // Hide line controls
    const lineControlsDiv = document.getElementById('line-controls');
    lineControlsDiv.style.display = 'none';
    
    // Remove handles
    clearLineHandles();
  }

  function deleteSelectedLine() {
    if (!selectedLine) return;
    
    if (selectedLine.type === 'level') {
      removeLevel(selectedLine.data.id);
      log('Level deleted');
    } else if (selectedLine.type === 'trendline') {
      removeTrendline(selectedLine.data.id);
      log('Trendline deleted');
    }
    
    // Hide line controls
    const lineControlsDiv = document.getElementById('line-controls');
    lineControlsDiv.style.display = 'none';
    
    selectedLine = null;
    isLineSelected = false;
    clearLineHandles();
  }

  // Add visual handles for line resizing
  function addLineHandles() {
    clearLineHandles(); // Remove any existing handles
    
    if (!selectedLine) return;
    
    const chartContainer = document.getElementById('chart');
    
    if (selectedLine.type === 'trendline') {
      // Add handles at both ends of trendline
      const data = selectedLine.data;
      
      // Start handle
      const startX = chart.timeScale().timeToCoordinate(data.startTime);
      const startY = candleSeries.priceToCoordinate(data.startPrice);
      
      if (startX !== null && startY !== null) {
        const startHandle = createHandle(startX, startY, 'grab');
        startHandle.dataset.handleType = 'start';
        startHandle.dataset.lineType = 'trendline';
        chartContainer.appendChild(startHandle);
        lineHandles.push(startHandle);
      }
      
      // End handle
      const endX = chart.timeScale().timeToCoordinate(data.endTime);
      const endY = candleSeries.priceToCoordinate(data.endPrice);
      
      if (endX !== null && endY !== null) {
        const endHandle = createHandle(endX, endY, 'grab');
        endHandle.dataset.handleType = 'end';
        endHandle.dataset.lineType = 'trendline';
        chartContainer.appendChild(endHandle);
        lineHandles.push(endHandle);
      }
      
      // Middle handle for moving entire trendline
      if (startX !== null && startY !== null && endX !== null && endY !== null) {
        const middleX = (startX + endX) / 2;
        const middleY = (startY + endY) / 2;
        
        const middleHandle = createHandle(middleX, middleY, 'move');
        middleHandle.dataset.handleType = 'middle';
        middleHandle.dataset.lineType = 'trendline';
        middleHandle.style.backgroundColor = '#22d3ee'; // Different color for middle handle
        middleHandle.style.border = '2px solid #0891b2';
        middleHandle.style.width = '16px'; // Slightly larger for easier grabbing
        middleHandle.style.height = '16px';
        middleHandle.style.left = (middleX - 8) + 'px';
        middleHandle.style.top = (middleY - 8) + 'px';
        chartContainer.appendChild(middleHandle);
        lineHandles.push(middleHandle);
      }
    } else if (selectedLine.type === 'level') {
      // Add a single handle for horizontal level (vertical movement only)
      const data = selectedLine.data;
      const levelY = candleSeries.priceToCoordinate(data.price);
      
      // Place handle in the middle of visible chart area
      const timeScale = chart.timeScale();
      const visibleRange = timeScale.getVisibleRange();
      if (visibleRange && levelY !== null) {
        const middleTime = (visibleRange.from + visibleRange.to) / 2;
        const middleX = timeScale.timeToCoordinate(middleTime);
        
        if (middleX !== null) {
          const levelHandle = createHandle(middleX, levelY, 'ns-resize');
          levelHandle.dataset.handleType = 'level';
          levelHandle.dataset.lineType = 'level';
          chartContainer.appendChild(levelHandle);
          lineHandles.push(levelHandle);
        }
      }
    }
  }

  function createHandle(x, y, cursor) {
    const handle = document.createElement('div');
    handle.style.position = 'absolute';
    handle.style.left = (x - 6) + 'px';
    handle.style.top = (y - 6) + 'px';
    handle.style.width = '12px';
    handle.style.height = '12px';
    handle.style.backgroundColor = '#22d3ee';
    handle.style.border = '2px solid #0891b2';
    handle.style.borderRadius = '50%';
    handle.style.cursor = cursor;
    handle.style.zIndex = '1000';
    handle.style.pointerEvents = 'auto';
    handle.classList.add('line-handle');
    
    return handle;
  }

  function updateLineHandles() {
    if (!selectedLine || lineHandles.length === 0) return;
    
    const chartContainer = document.getElementById('chart');
    
    if (selectedLine.type === 'trendline') {
      const data = selectedLine.data;
      
      // Update start handle
      if (lineHandles[0]) {
        const startX = chart.timeScale().timeToCoordinate(data.startTime);
        const startY = candleSeries.priceToCoordinate(data.startPrice);
        if (startX !== null && startY !== null) {
          lineHandles[0].style.left = (startX - 6) + 'px';
          lineHandles[0].style.top = (startY - 6) + 'px';
        }
      }
      
      // Update end handle
      if (lineHandles[1]) {
        const endX = chart.timeScale().timeToCoordinate(data.endTime);
        const endY = candleSeries.priceToCoordinate(data.endPrice);
        if (endX !== null && endY !== null) {
          lineHandles[1].style.left = (endX - 6) + 'px';
          lineHandles[1].style.top = (endY - 6) + 'px';
        }
      }
      
      // Update middle handle
      if (lineHandles[2]) {
        const startX = chart.timeScale().timeToCoordinate(data.startTime);
        const startY = candleSeries.priceToCoordinate(data.startPrice);
        const endX = chart.timeScale().timeToCoordinate(data.endTime);
        const endY = candleSeries.priceToCoordinate(data.endPrice);
        
        if (startX !== null && startY !== null && endX !== null && endY !== null) {
          const middleX = (startX + endX) / 2;
          const middleY = (startY + endY) / 2;
          lineHandles[2].style.left = (middleX - 8) + 'px'; // -8 because middle handle is 16px
          lineHandles[2].style.top = (middleY - 8) + 'px';
        }
      }
    } else if (selectedLine.type === 'level') {
      // Update level handle position (keep in middle of visible range)
      if (lineHandles[0]) {
        const data = selectedLine.data;
        const levelY = candleSeries.priceToCoordinate(data.price);
        const timeScale = chart.timeScale();
        const visibleRange = timeScale.getVisibleRange();
        
        if (visibleRange && levelY !== null) {
          const middleTime = (visibleRange.from + visibleRange.to) / 2;
          const middleX = timeScale.timeToCoordinate(middleTime);
          
          if (middleX !== null) {
            lineHandles[0].style.left = (middleX - 6) + 'px';
            lineHandles[0].style.top = (levelY - 6) + 'px';
          }
        }
      }
    }
  }

  // Drag functionality for handles
  let dragState = { isDragging: false, handleElement: null, isStart: false, isMiddle: false, lineType: null, originalStart: null, originalEnd: null, startMouseTime: null, startMousePrice: null };

  document.addEventListener('mousedown', (event) => {
    const handle = event.target.closest('.line-handle');
    if (handle) {
      event.preventDefault();
      dragState.isDragging = true;
      dragState.handleElement = handle;
      dragState.isStart = handle.dataset.handleType === 'start';
      dragState.lineType = handle.dataset.lineType;
      handle.style.cursor = dragState.lineType === 'level' ? 'ns-resize' : 'grabbing';
    }
  });

  document.addEventListener('mousemove', (event) => {
    if (dragState.isDragging && dragState.handleElement) {
      const chartContainer = document.getElementById('chart');
      const rect = chartContainer.getBoundingClientRect();
      const newX = event.clientX - rect.left;
      const newY = event.clientY - rect.top;
      
      // Update handle position
      dragState.handleElement.style.left = (newX - 6) + 'px';
      dragState.handleElement.style.top = (newY - 6) + 'px';
      
      // Update the actual line data with REAL-TIME visual feedback
      if (dragState.lineType === 'trendline') {
        // Handle trendline drag (both horizontal and vertical movement)
        
        // Add comprehensive validation to prevent chart crashes
        let newTime, newPrice;
        try {
          newTime = chart.timeScale().coordinateToTime(newX);
          newPrice = candleSeries.coordinateToPrice(newY);
        } catch (error) {
          console.warn('[EOD] Coordinate conversion error during drag:', error);
          return; // Stop processing invalid coordinates
        }
        
        // Enhanced validation: check for valid values AND reasonable bounds
        const isValidTime = newTime !== null && newTime !== undefined && !isNaN(newTime);
        const isValidPrice = newPrice !== null && newPrice !== undefined && !isNaN(newPrice) && isFinite(newPrice) && newPrice > 0;
        
        if (isValidTime && isValidPrice && selectedLine && selectedLine.data) {
          const symbolTrendlines = getTrendlinesForSymbol(currentSymbol, currentTimeframe);
          const trendlineIndex = symbolTrendlines.findIndex(t => t.id === selectedLine.data.id);
          if (trendlineIndex >= 0) {
            // Validate the trendline data before updating
            const currentTrendline = symbolTrendlines[trendlineIndex];
            let startTime = currentTrendline.startTime;
            let startPrice = currentTrendline.startPrice;
            let endTime = currentTrendline.endTime;
            let endPrice = currentTrendline.endPrice;
            
            if (dragState.isStart) {
              startTime = newTime;
              startPrice = newPrice;
            } else {
              endTime = newTime;
              endPrice = newPrice;
            }
            
            // Ensure both points are valid before updating
            if (startTime !== null && endTime !== null && startPrice > 0 && endPrice > 0) {
              symbolTrendlines[trendlineIndex].startTime = startTime;
              symbolTrendlines[trendlineIndex].startPrice = startPrice;
              symbolTrendlines[trendlineIndex].endTime = endTime;
              symbolTrendlines[trendlineIndex].endPrice = endPrice;
              
              selectedLine.data.startTime = startTime;
              selectedLine.data.startPrice = startPrice;
              selectedLine.data.endTime = endTime;
              selectedLine.data.endPrice = endPrice;
              
              // REAL-TIME visual update during drag - keeps handles attached!
              try {
                saveTrendlinesForSymbol(currentSymbol, currentTimeframe, symbolTrendlines);
                drawTrendlinesOnChart();
                updateLineHandles(); // Keep handles visually connected
              } catch (error) {
                console.warn('[EOD] Error during trendline redraw:', error);
              }
            }
          }
        }
        
      } else if (dragState.lineType === 'level') {
        // Handle horizontal level drag (vertical movement only)
        
        // Add comprehensive validation to prevent chart crashes
        let newPrice;
        try {
          newPrice = candleSeries.coordinateToPrice(newY);
        } catch (error) {
          console.warn('[EOD] Coordinate conversion error during level drag:', error);
          return; // Stop processing invalid coordinates
        }
        
        // Enhanced validation: check for valid price values
        const isValidPrice = newPrice !== null && newPrice !== undefined && !isNaN(newPrice) && isFinite(newPrice) && newPrice > 0;
        
        if (isValidPrice && selectedLine && selectedLine.data) {
          const symbolLevels = getLevelsForSymbol(currentSymbol, currentTimeframe);
          const levelIndex = symbolLevels.findIndex(l => l.id === selectedLine.data.id);
          if (levelIndex >= 0) {
            symbolLevels[levelIndex].price = newPrice;
            selectedLine.data.price = newPrice;
            
            // REAL-TIME visual update during drag - keeps handles attached!
            try {
              saveLevelsForSymbol(currentSymbol, currentTimeframe, symbolLevels);
              drawLevelsOnChart();
              updateLineHandles(); // Keep handles visually connected
            } catch (error) {
              console.warn('[EOD] Error during level redraw:', error);
            }
          }
        }
      }
    }
  });

  document.addEventListener('mouseup', (event) => {
    if (dragState.isDragging) {
      const chartContainer = document.getElementById('chart');
      const rect = chartContainer.getBoundingClientRect();
      const newX = event.clientX - rect.left;
      const newY = event.clientY - rect.top;
      
      // Final confirmation (real-time updates happen during mousemove)
      if (dragState.lineType === 'trendline') {
        const newTime = chart.timeScale().coordinateToTime(newX);
        const newPrice = candleSeries.coordinateToPrice(newY);
        
        if (newTime !== null && newTime !== undefined && newPrice !== null && !isNaN(newPrice)) {
          log('✅ Trendline resized - new position saved');
        } else {
          log('⚠️ Drag position out of bounds - trendline not moved');
        }
        
      } else if (dragState.lineType === 'level') {
        const newPrice = candleSeries.coordinateToPrice(newY);
        
        if (newPrice !== null && !isNaN(newPrice)) {
          log(`✅ Level moved to ${newPrice.toFixed(2)} - new position saved`);
        } else {
          log('⚠️ Drag position out of bounds - level not moved');
        }
      }
    }
    
    // Reset drag state and cursor
    if (dragState.handleElement && dragState.handleElement.parentNode) {
      dragState.handleElement.style.cursor = dragState.lineType === 'level' ? 'ns-resize' : 'grab';
    }
    dragState = { isDragging: false, handleElement: null, isStart: false, isMiddle: false, lineType: null, originalStart: null, originalEnd: null, startMouseTime: null, startMousePrice: null };
  });
  
  function clearLineHandles() { 
    // Reset cursor if actively dragging
    if (dragState.handleElement) {
      dragState.handleElement.style.cursor = dragState.lineType === 'level' ? 'ns-resize' : 'grab';
    }
    
    lineHandles.forEach(h=>h.remove()); 
    lineHandles=[]; 
    
    // Completely reset drag state
    dragState = { isDragging: false, handleElement: null, isStart: false, isMiddle: false, lineType: null, originalStart: null, originalEnd: null, startMouseTime: null, startMousePrice: null };
  }
  
  // Track chart viewport changes to keep handles synchronized
  function setupHandleTracking() {
    chart.timeScale().subscribeVisibleTimeRangeChange(() => {
      if (selectedLine && selectedLine.type === 'trendline') {
        updateLineHandles();
      }
    });
  }

  // ---- Event Listeners
  $('#add-btn').addEventListener('click', addSymbol);
  $('#new-symbol').addEventListener('keypress', e => e.key === 'Enter' && addSymbol());

  // Keyboard Delete functionality for selected lines
  document.addEventListener('keydown', (event) => {
    if (event.key === 'Delete' && selectedLine) {
      // Ignore Delete key when typing in inputs/textareas
      const activeElement = document.activeElement;
      if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.contentEditable === 'true')) {
        return; // Let the input handle the Delete key normally
      }
      
      event.preventDefault(); // Prevent default browser behavior
      
      if (selectedLine.type === 'level') {
        // Delete selected level line
        const symbolLevels = getLevelsForSymbol(currentSymbol, currentTimeframe);
        const levelIndex = symbolLevels.findIndex(l => l.id === selectedLine.data.id);
        if (levelIndex >= 0) {
          symbolLevels.splice(levelIndex, 1);
          saveLevelsForSymbol(currentSymbol, currentTimeframe, symbolLevels);
          drawLevelsOnChart();
          clearLineHandles();
          selectedLine = null;
          log(`🗑️ Level line deleted`);
        }
        
      } else if (selectedLine.type === 'trendline') {
        // Delete selected trendline
        const symbolTrendlines = getTrendlinesForSymbol(currentSymbol, currentTimeframe);
        const trendlineIndex = symbolTrendlines.findIndex(t => t.id === selectedLine.data.id);
        if (trendlineIndex >= 0) {
          symbolTrendlines.splice(trendlineIndex, 1);
          saveTrendlinesForSymbol(currentSymbol, currentTimeframe, symbolTrendlines);
          drawTrendlinesOnChart();
          clearLineHandles();
          selectedLine = null;
          log(`🗑️ Trendline deleted`);
        }
      }
    }
  });

  // Watchlist clicks
  $('#watchlist').addEventListener('click', e => {
    const item = e.target.closest('.symbol-item');
    if (item && !e.target.classList.contains('remove-btn')) {
      loadSymbol(item.dataset.symbol);
    }
  });

  // Indicator toggles
  $('#ema-toggle').addEventListener('click', () => {
    indicators.ema200 = !indicators.ema200;
    saveIndicators();
    updateIndicatorToggles();
    loadSymbol(currentSymbol); // refresh chart
  });

  $('#bb-toggle').addEventListener('click', () => {
    indicators.bb20 = !indicators.bb20;
    saveIndicators();
    updateIndicatorToggles();
    loadSymbol(currentSymbol); // refresh chart
  });

  // Drawing tool buttons
  $('#level-tool').addEventListener('click', () => {
    if (drawingTool === 'level' && drawingMode) {
      // Turn off drawing mode
      drawingMode = false;
      $('#level-tool').classList.remove('active');
      document.body.classList.remove('drawing-mode');
      log('Drawing mode off');
    } else {
      // Switch to level tool
      disableTrendlinePreview(); // Clean up any preview
      drawingMode = true;
      drawingTool = 'level';
      trendlineStart = null; // Reset trendline state
      $('#level-tool').classList.add('active');
      $('#trendline-tool').classList.remove('active');
      document.body.classList.add('drawing-mode');
      log('Click chart to add level');
    }
  });

  $('#trendline-tool').addEventListener('click', () => {
    if (drawingTool === 'trendline' && drawingMode) {
      // Turn off drawing mode
      drawingMode = false;
      trendlineStart = null;
      disableTrendlinePreview();
      $('#trendline-tool').classList.remove('active');
      document.body.classList.remove('drawing-mode');
      log('Drawing mode off');
    } else {
      // Switch to trendline tool
      disableTrendlinePreview(); // Clean up any existing preview
      drawingMode = true;
      drawingTool = 'trendline';
      trendlineStart = null;
      $('#trendline-tool').classList.add('active');
      $('#level-tool').classList.remove('active');
      document.body.classList.add('drawing-mode');
      log('Click chart to place first point of trendline');
    }
  });

  $('#clear-all').addEventListener('click', () => {
    if (confirm('Clear all levels and trendlines for ' + currentSymbol + '?')) {
      clearAllLevels();
      clearAllTrendlines();
      log('All levels and trendlines cleared');
    }
  });

  // Color picker and delete button event listeners
  document.getElementById('delete-line').addEventListener('click', deleteSelectedLine);
  document.querySelectorAll('.color-option').forEach(opt => {
    opt.addEventListener('click', () => {
      if (!selectedLine) return;
      const color = opt.dataset.color;
      selectedLine.data.color = color;
      if (selectedLine.type === 'trendline') { 
        saveTrendlines(); 
        drawTrendlinesOnChart(); 
      } else { 
        saveLevels(); 
        drawLevelsOnChart(); 
      }
      // Keep selection visible after redraw
      selectLine(selectedLine);
      log(`Changed line color to ${color}`);
    });
  });

  // Enhanced timeframe buttons with full multi-timeframe support
  $$('.tf.btn-toggle').forEach(btn => {
    btn.addEventListener('click', () => {
      const tf = btn.dataset.tf;
      
      if (tf !== currentTimeframe) {
        // Handle 4H timeframe limitation with user notification
        if (tf === '4H') {
          if (!confirm('⚠️ 4H charts currently show daily data due to limited intraday history from data provider.\n\nWould you like to continue anyway?')) {
            return; // User cancelled, keep current timeframe
          }
          log('4H timeframe selected (showing daily data due to limited intraday history)');
        } else {
          log(`${tf} timeframe selected`);
        }
        
        currentTimeframe = tf;
        updateTimeframeDisplay();
        loadSymbol(currentSymbol, currentTimeframe);
      }
    });
  });

  // ---- Preview functions for trendline drawing
  function enableTrendlinePreview() {
    if (!trendlineStart) return;
    
    previewTrendline = chart.addLineSeries({
      color: '#94a3b8', // Gray preview color
      lineWidth: 1,
      lineStyle: 2 // Dashed line style for preview
    });
  }

  function updateTrendlinePreview(endTime, endPrice) {
    if (previewTrendline && trendlineStart) {
      previewTrendline.setData([
        { time: trendlineStart.time, value: trendlineStart.price },
        { time: endTime, value: endPrice }
      ]);
    }
  }

  function disableTrendlinePreview() {
    // Clear throttle timer to prevent memory leaks
    if (previewUpdateThrottle) {
      clearTimeout(previewUpdateThrottle);
      previewUpdateThrottle = null;
    }
    
    if (previewTrendline) {
      chart.removeSeries(previewTrendline);
      previewTrendline = null;
    }
  }

  // ---- Initialize
  updateWatchlistDisplay();
  updateIndicatorToggles();
  updateLevelsDisplay();
  updateTrendlinesDisplay();
  setupChartInteraction();
  setupHandleTracking();
  loadSymbol(currentSymbol);

  // health check with status indicator
  fetch(`${API}/healthz`)
    .then(r => {
      if (r.ok) {
        log('Backend OK');
        $('#status-dot').className = 'status-dot status-connected';
      } else {
        log('Backend NOT OK');
        $('#status-dot').className = 'status-dot status-error';
      }
    })
    .catch(e => {
      log('Backend connection failed');
      $('#status-dot').className = 'status-dot status-error';
    });

  // ================================================
  // SIGNAL DETECTION & CROSSING ANALYSIS SYSTEM
  // ================================================
  
  // Core crossing detection function
  function crossed(prevA, prevB, curA, curB) {
    if ([prevA,prevB,curA,curB].some(v=>!Number.isFinite(v))) return false;
    const d1 = prevA - prevB, d2 = curA - curB;
    return (d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0);
  }

  // EMA calculation from bars
  function emaFromBars(bars, period) {
    if (!bars?.length) return [];
    const k = 2 / (period + 1);
    let e = bars[0].close;
    const out = [{ time: bars[0].time, value: e }];
    for (let i=1;i<bars.length;i++) {
      e = bars[i].close*k + e*(1-k);
      out.push({ time: bars[i].time, value: e });
    }
    return out;
  }

  // Bollinger Bands calculation from bars
  function bbFromBars(bars, period=20, mult=2) {
    const outU=[], outM=[], outL=[];
    const closes = bars.map(b=>b.close);
    const sma = (arr, n, i) => {
      if (i < n-1) return null;
      let s=0; for (let k=i-n+1;k<=i;k++) s+=arr[k];
      return s/n;
    };
    for (let i=0;i<bars.length;i++){
      const m = sma(closes, period, i);
      if (m == null) { outU.push(null); outM.push(null); outL.push(null); continue; }
      let v=0; for (let k=i-period+1;k<=i;k++) v += (closes[k]-m)*(closes[k]-m);
      const sd = Math.sqrt(v/period);
      outU.push({ time: bars[i].time, value: m + mult*sd });
      outM.push({ time: bars[i].time, value: m });
      outL.push({ time: bars[i].time, value: m - mult*sd });
    }
    return { upper: outU.filter(Boolean), middle: outM.filter(Boolean), lower: outL.filter(Boolean) };
  }

  // Calculate value on trendline at specific time
  function valueOnTrendAt(tr, t) {
    if (tr.endTime === tr.startTime) return tr.startPrice;
    const m = (tr.endPrice - tr.startPrice) / (tr.endTime - tr.startTime);
    return tr.startPrice + m * (t - tr.startTime);
  }

  // Main signal evaluation function
  function evaluateCrossSuite(bars, levels=[], trends=[], opts={ useEMA200:true, useBB:true }) {
    const N = bars.length;
    if (N < 2) return { ema:null, bb:null, level:[], trend:[] };

    const prev = bars[N-2].close;
    const cur  = bars[N-1].close;
    const tPrev= bars[N-2].time;
    const tCur = bars[N-1].time;

    const out = { ema:null, bb:null, level:[], trend:[] };

    // EMA200 analysis
    if (opts.useEMA200) {
      const ema200 = emaFromBars(bars, 200);
      const ePrev = ema200[ema200.length-2]?.value;
      const eCur  = ema200[ema200.length-1]?.value;
      if (Number.isFinite(ePrev) && Number.isFinite(eCur)) {
        if (crossed(prev, ePrev, cur, eCur)) {
          out.ema = (cur > eCur) ? 'ema_cross_up' : 'ema_cross_down';
        } else {
          out.ema = (cur >= eCur) ? 'ema_above' : 'ema_below';
        }
      }
      out._emaValue = eCur; // optional for display
    }

    // Bollinger Bands (20,2) analysis
    if (opts.useBB) {
      const bb = bbFromBars(bars, 20, 2);
      const uPrev = bb.upper.at(-2)?.value, uCur = bb.upper.at(-1)?.value;
      const lPrev = bb.lower.at(-2)?.value, lCur = bb.lower.at(-1)?.value;

      if (Number.isFinite(uPrev) && Number.isFinite(uCur)) {
        if (crossed(prev, uPrev, cur, uCur)) out.bb = (cur > uCur) ? 'above_upper_cross' : 'below_upper_cross';
        else if (cur > uCur) out.bb = 'above_upper';
      }
      if (Number.isFinite(lPrev) && Number.isFinite(lCur)) {
        if (crossed(prev, lPrev, cur, lCur)) out.bb = (cur < lCur) ? 'below_lower_cross' : 'above_lower_cross';
        else if (cur < lCur) out.bb = 'below_lower';
      }
      out._bbUpper = uCur; out._bbLower = lCur; // optional
    }

    // Level crossings analysis
    for (const L of levels) {
      const p = +L.price;
      if (!Number.isFinite(p)) continue;
      if (crossed(prev, p, cur, p)) {
        out.level.push({ id:L.id, dir: cur > p ? 'cross_up' : 'cross_down', price:p, label:L.label||null });
      } else {
        out.level.push({ id:L.id, dir: cur > p ? 'above' : 'below', price:p, label:L.label||null });
      }
    }

    // Trendline crossings analysis
    for (const tr of trends) {
      const yPrev = valueOnTrendAt(tr, tPrev);
      const yCur  = valueOnTrendAt(tr, tCur);
      if (!Number.isFinite(yPrev) || !Number.isFinite(yCur)) continue;
      if (crossed(prev, yPrev, cur, yCur)) {
        out.trend.push({ id: tr.id, dir: cur > yCur ? 'cross_up' : 'cross_down' });
      } else {
        out.trend.push({ id: tr.id, dir: cur > yCur ? 'above' : 'below' });
      }
    }

    return out;
  }

  // ================================================
  // TEST MODE INFRASTRUCTURE
  // ================================================
  
  // Test Mode state
  let TEST_TIMER = null;
  let testBars = [];          // 1m bars we're generating
  let baseFrom = null;        // start from last real close
  let testSpeedMs = 250;      // 4 bars/sec; tweak to taste

  function cloneBar(b){ return { time:b.time, open:b.open, high:b.high, low:b.low, close:b.close }; }

  // Random-walk 1m bar around last close; "volBp" = basis points of vol
  function genNextMinute(prevBar, volBp = 25) {
    const t = (prevBar.time + 60); // +1 minute (seconds epoch)
    const drift = 0; // set small drift if you want an up/down bias
    const vol = prevBar.close * (volBp / 10000);
    const delta = (Math.random() - 0.5) * 2 * vol + drift;

    const open = prevBar.close;
    const close = Math.max(0.01, open + delta);
    const high = Math.max(open, close) + Math.random()*vol*0.5;
    const low  = Math.min(open, close) - Math.random()*vol*0.5;

    return { time:t, open, high, low, close };
  }

  // Switch chart into "test mode" series (still using same series)
  function testInitFromCurrent() {
    if (!tfBars?.length) return;
    const last = tfBars.at(-1);
    baseFrom = cloneBar(last);
    // Bootstrap 200 seed minutes so EMA/BB have data
    testBars = [baseFrom];
    for (let i=0;i<220;i++) testBars.push(genNextMinute(testBars.at(-1), 18));
    candle.setData(testBars);
    emaSeries.setData(emaFromBars(testBars, 200));
    const bb = bbFromBars(testBars, 20, 2);
    bbUpperSeries.setData(bb.upper);
    bbMiddleSeries.setData(bb.middle);
    bbLowerSeries.setData(bb.lower);
    chart.timeScale().fitContent();
    log('Test mode initialized with synthetic 1-minute bars');
  }

  // Append 1 minute & evaluate crossings
  function testTick() {
    const next = genNextMinute(testBars.at(-1), 22);
    testBars.push(next);
    candle.update(next);

    // Update indicators incrementally
    const emaArr = emaFromBars(testBars, 200);     // fine for test; optimize later if needed
    emaSeries.setData(emaArr);
    const bb = bbFromBars(testBars, 20, 2);
    bbUpperSeries.setData(bb.upper);
    bbMiddleSeries.setData(bb.middle);
    bbLowerSeries.setData(bb.lower);

    // Evaluate vs your saved drawings on current symbol+TF
    const levels = getLevelsForSymbol(currentSymbol, currentTimeframe);
    const trends = getTrendlinesForSymbol(currentSymbol, currentTimeframe);

    const res = evaluateCrossSuite(testBars, levels, trends, { useEMA200:true, useBB:true });

    // Update signals panel with live results
    updateSignalsPanel(res);

    // Log important crossings
    if (res.ema && res.ema.includes('cross')) {
      log(`🎯 EMA CROSS: ${res.ema.includes('up') ? 'Price crossed ABOVE EMA200' : 'Price crossed BELOW EMA200'}`);
    }
    if (res.bb && res.bb.includes('cross')) {
      log(`🎯 BB CROSS: ${res.bb.replace('_', ' ')}`);
    }
    res.level.forEach(L => {
      if (L.dir.includes('cross')) {
        log(`🎯 LEVEL CROSS: ${L.price} - ${L.dir.includes('up') ? 'Price crossed ABOVE' : 'Price crossed BELOW'}`);
      }
    });
    res.trend.forEach(T => {
      if (T.dir.includes('cross')) {
        log(`🎯 TREND CROSS: ${T.dir.includes('up') ? 'Price crossed ABOVE trendline' : 'Price crossed BELOW trendline'}`);
      }
    });
  }

  // ================================================
  // SIGNAL DISPLAY SYSTEM
  // ================================================
  
  // Create a signal chip element
  function chip(text, type = 'good') {
    const c = document.createElement('div');
    c.className = `chip ${type}`;
    c.textContent = text;
    return c;
  }

  // Update signals panel with real-time signal evaluation
  function updateSignalsPanel(signalResults) {
    const chipsBox = document.getElementById('chips');
    chipsBox.innerHTML = '';
    
    // EMA signals
    if (signalResults.ema) {
      const emaText = signalResults.ema.includes('cross') 
        ? (signalResults.ema.includes('up') ? 'EMA ↑ CROSS' : 'EMA ↓ CROSS')
        : (signalResults.ema.includes('above') ? 'EMA Above' : 'EMA Below');
      const emaType = signalResults.ema.includes('cross') 
        ? (signalResults.ema.includes('up') ? 'good' : 'bad')
        : 'warn';
      chipsBox.appendChild(chip(emaText, emaType));
    }
    
    // Bollinger Band signals
    if (signalResults.bb) {
      const bbText = signalResults.bb.includes('cross')
        ? signalResults.bb.replace(/_/g, ' ').toUpperCase()
        : signalResults.bb.replace(/_/g, ' ');
      const bbType = signalResults.bb.includes('cross') ? 'warn' : 'good';
      chipsBox.appendChild(chip(bbText, bbType));
    }
    
    // Level crossing signals
    signalResults.level.forEach(L => {
      const levelText = `${L.label || L.price.toFixed(2)} ${L.dir.includes('up') ? '↑' : '↓'}`;
      const levelType = L.dir.includes('cross') 
        ? (L.dir.includes('up') ? 'good' : 'bad')
        : 'warn';
      chipsBox.appendChild(chip(levelText, levelType));
    });
    
    // Trendline crossing signals
    signalResults.trend.forEach(T => {
      const trendText = `Trend ${T.dir.includes('up') ? '↑' : '↓'}`;
      const trendType = T.dir.includes('cross')
        ? (T.dir.includes('up') ? 'good' : 'bad')
        : 'warn';
      chipsBox.appendChild(chip(trendText, trendType));
    });

    // Show "No Signals" if empty
    if (chipsBox.children.length === 0) {
      chipsBox.appendChild(chip('No Active Signals', 'warn'));
    }
  }

  // Evaluate signals for current real data
  function evaluateCurrentSignals() {
    if (!tfBars || tfBars.length < 2) return;
    
    const levels = getLevelsForSymbol(currentSymbol, currentTimeframe);
    const trends = getTrendlinesForSymbol(currentSymbol, currentTimeframe);
    const res = evaluateCrossSuite(tfBars, levels, trends, { useEMA200:true, useBB:true });
    
    updateSignalsPanel(res);
  }

  // Test mode controls
  document.getElementById('testStart').onclick = ()=>{
    if (!testBars.length) testInitFromCurrent();
    if (TEST_TIMER) return;
    TEST_TIMER = setInterval(testTick, testSpeedMs);
    log('Test mode started - synthetic bars running at 4 bars/second');
  };

  document.getElementById('testStep').onclick = ()=>{
    if (!testBars.length) testInitFromCurrent();
    testTick();
  };

  document.getElementById('testStop').onclick = ()=>{
    if (TEST_TIMER) { clearInterval(TEST_TIMER); TEST_TIMER = null; }
    log('Test mode stopped');
  };

  document.getElementById('testReset').onclick = ()=>{
    if (TEST_TIMER) { clearInterval(TEST_TIMER); TEST_TIMER = null; }
    testBars = [];
    // Restore original bars for current TF
    loadSymbol(currentSymbol, currentTimeframe);
    log('Test mode reset - restored real market data');
  };

  // removeSymbol no longer needs to be global (using event delegation)

  // ================================================
  // ALERT MODAL SYSTEM
  // ================================================
  
  let currentAlertLine = null; // Store the line/indicator being configured
  
  // Open alert modal for a clicked line or indicator
  function openAlertModal(lineInfo) {
    currentAlertLine = lineInfo;
    const modal = document.getElementById('alert-modal');
    const title = document.getElementById('alert-modal-title');
    const info = document.getElementById('alert-line-info');
    const abovePrice = document.getElementById('alert-above-price');
    const belowPrice = document.getElementById('alert-below-price');
    
    // Set modal title based on line type
    if (lineInfo.type === 'level') {
      title.textContent = `Alert for Level Line`;
      info.textContent = `Symbol: ${currentSymbol} | Level: $${lineInfo.price.toFixed(2)}`;
      abovePrice.textContent = `$${lineInfo.price.toFixed(2)}`;
      belowPrice.textContent = `$${lineInfo.price.toFixed(2)}`;
    } else if (lineInfo.type === 'trendline') {
      title.textContent = `Alert for Trendline`;
      info.textContent = `Symbol: ${currentSymbol} | Dynamic trendline price`;
      abovePrice.textContent = 'trend line';
      belowPrice.textContent = 'trend line';
    } else if (lineInfo.type === 'ema') {
      title.textContent = `Alert for EMA(200)`;
      info.textContent = `Symbol: ${currentSymbol} | EMA(200) current value`;
      abovePrice.textContent = 'EMA(200)';
      belowPrice.textContent = 'EMA(200)';
    } else if (lineInfo.type === 'bb_upper') {
      title.textContent = `Alert for Bollinger Band Upper`;
      info.textContent = `Symbol: ${currentSymbol} | Upper Bollinger Band`;
      abovePrice.textContent = 'upper band';
      belowPrice.textContent = 'upper band';
    } else if (lineInfo.type === 'bb_lower') {
      title.textContent = `Alert for Bollinger Band Lower`;
      info.textContent = `Symbol: ${currentSymbol} | Lower Bollinger Band`;
      abovePrice.textContent = 'lower band';
      belowPrice.textContent = 'lower band';
    }
    
    modal.style.display = 'flex';
  }
  
  // Close alert modal
  window.closeAlertModal = function() {
    document.getElementById('alert-modal').style.display = 'none';
    currentAlertLine = null;
  }
  
  // Set alert direction (above/below)
  window.setAlertDirection = function(direction) {
    if (!currentAlertLine) return;
    
    const alertConfig = {
      symbol: currentSymbol,
      timeframe: currentTimeframe,
      lineType: currentAlertLine.type,
      lineId: currentAlertLine.id || null,
      direction: direction, // 'above' or 'below'
      price: currentAlertLine.price || null,
      trendlineData: currentAlertLine.trendlineData || null,
      created: Date.now()
    };
    
    // Store alert configuration (not triggering yet)
    storeAlertConfig(alertConfig);
    
    log(`Alert set: ${currentSymbol} close ${direction} ${currentAlertLine.type === 'level' ? '$' + currentAlertLine.price.toFixed(2) : currentAlertLine.type}`);
    closeAlertModal();
  }
  
  // Store alert configuration in localStorage 
  function storeAlertConfig(config) {
    const alertsKey = 'eod-alert-configs';
    const existingAlerts = JSON.parse(localStorage.getItem(alertsKey) || '[]');
    
    // Remove any existing alert for same line/indicator
    const filteredAlerts = existingAlerts.filter(alert => 
      !(alert.symbol === config.symbol && 
        alert.timeframe === config.timeframe &&
        alert.lineType === config.lineType &&
        alert.lineId === config.lineId)
    );
    
    filteredAlerts.push(config);
    localStorage.setItem(alertsKey, JSON.stringify(filteredAlerts));
    
    // Show confirmation
    updateAlertsDisplay();
  }
  
  // Show stored alerts (for debugging - will enhance later)
  function updateAlertsDisplay() {
    const alertsKey = 'eod-alert-configs';
    const alerts = JSON.parse(localStorage.getItem(alertsKey) || '[]');
    console.log('[ALERTS] Stored configurations:', alerts);
  }
  
  // Helper function to calculate price on trendline at specific time
  function calculateTrendlinePrice(trendlineData, time) {
    if (!trendlineData || !time) return 0;
    
    const timeDelta = trendlineData.endTime - trendlineData.startTime;
    const priceDelta = trendlineData.endPrice - trendlineData.startPrice;
    
    if (timeDelta === 0) return trendlineData.startPrice;
    
    const timeRatio = (time - trendlineData.startTime) / timeDelta;
    return trendlineData.startPrice + (priceDelta * timeRatio);
  }

  // Close modal on outside click
  document.getElementById('alert-modal').addEventListener('click', function(e) {
    if (e.target === this) {
      closeAlertModal();
    }
  });

})();
</script>
</body>
</html>